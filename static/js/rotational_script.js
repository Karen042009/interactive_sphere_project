// --- Encyclopedic Theory Content (Armenian, Russian, English) ---
const theoryContent = {
    hy: `
        <!-- 1. CYLINDER -->
        <div class="theory-block">
            <h2>1. ‘≥’¨’°’∂ (Cylinder)</h2>
            <p><strong>’ç’°’∞’¥’°’∂’∏÷Ç’¥.</strong> ’à÷Ç’≤’´’≤ ’£’¨’°’∂’® ’¥’°÷Ä’¥’´’∂ ’ß, ’∏÷Ä’∂ ’°’º’°’ª’°’∂’∏÷Ç’¥ ’ß ’∏÷Ç’≤’≤’°’∂’Ø’µ’∏÷Ç’∂’® ’´÷Ä ’Ø’∏’≤’¥’•÷Ä’´÷Å ’¥’•’Ø’´ ’∑’∏÷Ç÷Ä’ª ’∫’ø’ø’•’¨’´’Ω: ‘±’µ’∂ ’∏÷Ç’≤’´’≤’®, ’∏÷Ä’´ ’∑’∏÷Ç÷Ä’ª ’Ø’°’ø’°÷Ä’æ’∏÷Ç’¥ ’ß ’∫’ø’∏÷Ç’µ’ø’®, ’Ø’∏’π’æ’∏÷Ç’¥ ’ß <em>’£’¨’°’∂’´ ’°’º’°’∂÷Å÷Ñ</em>:</p>
            
            <h3>’Ä’´’¥’∂’°’Ø’°’∂ ’è’°÷Ä÷Ä’•÷Ä’® ÷á ’Ä’°’ø’Ø’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä’®</h3>
            <ul>
                <li><strong>’Ä’´’¥÷Ñ’•÷Ä.</strong> ‘±’º’°’∂÷Å÷Ñ’´’∂ ’∏÷Ç’≤’≤’°’∞’°’µ’°÷Å ’•÷Ä’Ø’∏÷Ç ’∞’°’æ’°’Ω’°÷Ä ’∑÷Ä’ª’°’∂’∂’•÷Ä:</li>
                <li><strong>‘æ’∂’∏÷Ä’§’∂’•÷Ä.</strong> ’Ä’´’¥÷Ñ’•÷Ä’´ ’∑÷Ä’ª’°’∂’°’£’Æ’•÷Ä’´ ’∞’°’¥’°’∫’°’ø’°’Ω’≠’°’∂ ’Ø’•’ø’•÷Ä’® ’¥’´’°÷Å’∂’∏’≤ ’∞’°’ø’æ’°’Æ’∂’•÷Ä: ‘¥÷Ä’°’∂÷Ñ ’¶’∏÷Ç’£’°’∞’•’º ’•’∂ ’°’º’°’∂÷Å÷Ñ’´’∂ ÷á ’∞’°’æ’°’Ω’°÷Ä ’•’∂ ’´÷Ä’°÷Ä:</li>
                <li><strong>‘±’º’°’∂÷Å÷Ñ’°’µ’´’∂ ’Ä’°’ø’∏÷Ç’µ’©.</strong> ‘±’º’°’∂÷Å÷Ñ’∏’æ ’°’∂÷Å’∂’∏’≤ ’∞’°÷Ä’©’∏÷Ç’©’µ’°’¥’¢ ’∞’°’ø’∏÷Ç’µ’©’® ’∏÷Ç’≤’≤’°’∂’Ø’µ’∏÷Ç’∂ ’ß:</li>
            </ul>

            <h3>‘≤’°’∂’°’±÷á’•÷Ä’´ ‘±÷Ä’ø’°’Æ’∏÷Ç’¥</h3>
            <div class="formula-box">
                <p><strong>‘ø’∏’≤’¥’∂’°’µ’´’∂ ’Ñ’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’´ ’Ñ’°’Ø’•÷Ä’•’Ω.</strong> ‘≥’¨’°’∂’´ ÷É’º’æ’°’Æ÷Ñ’® ’∏÷Ç’≤’≤’°’∂’Ø’µ’∏÷Ç’∂ ’ß, ’∏÷Ä’´ ’Ø’∏’≤’¥’•÷Ä’∂ ’•’∂ ’∞’´’¥÷Ñ’´ ’∑÷Ä’ª’°’∂’°’£’Æ’´ ’•÷Ä’Ø’°÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’® ($2\\pi R$) ÷á ’¢’°÷Ä’±÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’® ($H$): <br> $$ S_{k} = 2\\pi R H $$</p>
                <p><strong>‘º÷Ä’´’æ ’Ñ’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’´ ’Ñ’°’Ø’•÷Ä’•’Ω.</strong> ‘≥’∏÷Ç’¥’°÷Ä’æ’∏÷Ç’¥ ’ß ’•÷Ä’Ø’∏÷Ç ’∞’´’¥÷Ñ’•÷Ä’´ ’¥’°’Ø’•÷Ä’•’Ω’∂’•÷Ä’® ($2 \\cdot \\pi R^2$): <br> $$ S_{l} = 2\\pi R H + 2\\pi R^2 = 2\\pi R(H+R) $$</p>
                <p><strong>‘æ’°’æ’°’¨.</strong> ’Ä’´’¥÷Ñ’´ ’¥’°’Ø’•÷Ä’•’Ω’´ ÷á ’¢’°÷Ä’±÷Ä’∏÷Ç’©’µ’°’∂ ’°÷Ä’ø’°’§÷Ä’µ’°’¨’® (‘ø’°’æ’°’¨’´’•÷Ä’´’´ ’Ω’Ø’¶’¢’∏÷Ç’∂÷Ñ’∏’æ): <br> $$ V = \\pi R^2 H $$</p>
            </div>
        </div>

        <!-- 2. CONE -->
        <div class="theory-block">
            <h2>2. ‘ø’∏’∂ (Cone)</h2>
            <p><strong>’ç’°’∞’¥’°’∂’∏÷Ç’¥.</strong> ’à÷Ç’≤’´’≤ ’Ø’∏’∂’® ’¥’°÷Ä’¥’´’∂ ’ß, ’∏÷Ä’∂ ’°’º’°’ª’°’∂’∏÷Ç’¥ ’ß ’∏÷Ç’≤’≤’°’∂’Ø’µ’∏÷Ç’∂ ’•’º’°’∂’Ø’µ’∏÷Ç’∂’® ’´÷Ä ’ß’ª’•÷Ä’´÷Å ’¥’•’Ø’´ (’°’º’°’∂÷Å÷Ñ’´) ’∑’∏÷Ç÷Ä’ª ’∫’ø’ø’•’¨’´’Ω: ’Ñ’µ’∏÷Ç’Ω ’ß’ª’® ’£’Æ’∏÷Ç’¥ ’ß ’Ø’∏’∂’´ ’∞’´’¥÷Ñ’® (’∑÷Ä’ª’°’∂), ’´’Ω’Ø ’∂’•÷Ä÷Ñ’∂’°’±’´’£’®’ù ’Ø’∏’≤’¥’∂’°’µ’´’∂ ’¥’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’®:</p>

            <h3>’Ä’´’¥’∂’°’Ø’°’∂ ’è’°÷Ä÷Ä’•÷Ä’® ÷á ’Ä’°’ø’Ø’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä’®</h3>
            <ul>
                <li><strong>‘≥’°’£’°’©.</strong> ‘±’º’°’∂÷Å÷Ñ’´ ÷á ’Æ’∂’∏÷Ä’§’∂’•÷Ä’´ ’∞’°’ø’¥’°’∂ ’Ø’•’ø’®:</li>
                <li><strong>‘æ’∂’∏÷Ä’§ ($l$).</strong> ‘≥’°’£’°’©’® ’∞’´’¥÷Ñ’´ ’∑÷Ä’ª’°’∂’°’£’Æ’´ ’Ø’•’ø’•÷Ä’´’∂ ’¥’´’°÷Å’∂’∏’≤ ’∞’°’ø’æ’°’Æ’∂’•÷Ä’®: ‘≤’∏’¨’∏÷Ä ’Æ’∂’∏÷Ä’§’∂’•÷Ä’® ’∞’°’æ’°’Ω’°÷Ä ’•’∂:</li>
                <li><strong>‘±’º’°’∂÷Å÷Ñ’°’µ’´’∂ ’Ä’°’ø’∏÷Ç’µ’©.</strong> ‘±’º’°’∂÷Å÷Ñ’∏’æ ’°’∂÷Å’∂’∏’≤ ’∞’°÷Ä’©’∏÷Ç’©’µ’°’¥’¢ ’∞’°’ø’∏÷Ç’µ’©’® ’∞’°’æ’°’Ω’°÷Ä’°’Ω÷Ä’∏÷Ç’∂ ’•’º’°’∂’Ø’µ’∏÷Ç’∂ ’ß:</li>
            </ul>

            <h3>‘≤’°’∂’°’±÷á’•÷Ä’´ ‘±÷Ä’ø’°’Æ’∏÷Ç’¥</h3>
            <div class="formula-box">
                <p><strong>‘ø’°’∫’® ’ø’°÷Ä÷Ä’•÷Ä’´ ’¥’´’ª÷á (’ä’µ’∏÷Ç’©’°’£’∏÷Ä’°’Ω).</strong> $$ l^2 = R^2 + H^2 $$</p>
                <p><strong>‘ø’∏’≤’¥’∂’°’µ’´’∂ ’Ñ’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’´ ’Ñ’°’Ø’•÷Ä’•’Ω.</strong> ‘ø’∏’∂’´ ÷É’º’æ’°’Æ÷Ñ’® ’∑÷Ä’ª’°’∂’°’µ’´’∂ ’Ω’•’Ø’ø’∏÷Ä ’ß, ’∏÷Ä’´ ’∑’°’º’°’æ’´’≤’® $l$ ’ß, ’´’Ω’Ø ’°’≤’•’≤’´ ’•÷Ä’Ø’°÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’®’ù $2\\pi R$: <br> $$ S_{k} = \\frac{1}{2} l \\cdot (2\\pi R) = \\pi R l $$</p>
                <p><strong>‘º÷Ä’´’æ ’Ñ’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’´ ’Ñ’°’Ø’•÷Ä’•’Ω.</strong> $$ S_{l} = S_{k} + S_{h} = \\pi R l + \\pi R^2 = \\pi R (l + R) $$</p>
                <p><strong>‘æ’°’æ’°’¨.</strong> ’Ä’°’æ’°’Ω’°÷Ä ’ß ’∂’∏÷Ç’µ’∂ ’∞’´’¥÷Ñ’∏’æ ÷á ’¢’°÷Ä’±÷Ä’∏÷Ç’©’µ’°’¥’¢ ’£’¨’°’∂’´ ’Æ’°’æ’°’¨’´ ’¥’•’Ø ’•÷Ä÷Ä’∏÷Ä’§’´’∂: <br> $$ V = \\frac{1}{3}\\pi R^2 H $$</p>
            </div>
        </div>

        <!-- 3. FRUSTUM -->
        <div class="theory-block">
            <h2>3. ’Ä’°’ø’°’Æ ‘ø’∏’∂ (Frustum)</h2>
            <p><strong>’ç’°’∞’¥’°’∂’∏÷Ç’¥.</strong> ’Ä’°’ø’°’Æ ’Ø’∏’∂’® ’°’º’°’ª’°’∂’∏÷Ç’¥ ’ß, ’•÷Ä’¢ ’Ø’∏’∂’® ’∞’°’ø’∏÷Ç’¥ ’•’∂÷Ñ ’∂÷Ä’° ’∞’´’¥÷Ñ’´’∂ ’¶’∏÷Ç’£’°’∞’•’º ’∞’°÷Ä’©’∏÷Ç’©’µ’°’¥’¢: ‘±’µ’∂ ’Ø’°÷Ä’•’¨’´ ’ß ’§’´’ø’°÷Ä’Ø’•’¨ ’∂’°÷á ’∏÷Ä’∫’•’Ω ’∏÷Ç’≤’≤’°’∂’Ø’µ’∏÷Ç’∂ ’Ω’•’≤’°’∂’´ ’∫’ø’∏÷Ç’µ’ø ’´÷Ä ÷É’∏÷Ñ÷Ä ’Ω÷Ä’∏÷Ç’∂÷Ñ’´ (’°’º’°’∂÷Å÷Ñ’´) ’∑’∏÷Ç÷Ä’ª:</p>

            <h3>’Ä’´’¥’∂’°’Ø’°’∂ ’è’°÷Ä÷Ä’•÷Ä’®</h3>
            <ul>
                <li><strong>’Ä’´’¥÷Ñ’•÷Ä.</strong> ‘µ÷Ä’Ø’∏÷Ç ’¶’∏÷Ç’£’°’∞’•’º ’∑÷Ä’ª’°’∂’∂’•÷Ä ($R$ ÷á $r$ ’∑’°’º’°’æ’´’≤’∂’•÷Ä’∏’æ):</li>
                <li><strong>‘≤’°÷Ä’±÷Ä’∏÷Ç’©’µ’∏÷Ç’∂ ($H$).</strong> ’Ä’´’¥÷Ñ’•÷Ä’´ ’Ø’•’∂’ø÷Ä’∏’∂’∂’•÷Ä’´ ’∞’•’º’°’æ’∏÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’®:</li>
                <li><strong>‘æ’∂’∏÷Ä’§ ($l$).</strong> ’Ä’´’¥÷Ñ’•÷Ä’´ ’∑÷Ä’ª’°’∂’°’£’Æ’•÷Ä’® ’¥’´’°÷Å’∂’∏’≤ ’∞’°’ø’æ’°’Æ’® ’Ø’∏’≤’¥’∂’°’µ’´’∂ ’¥’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’´ ’æ÷Ä’°:</li>
            </ul>

            <h3>‘≤’°’∂’°’±÷á’•÷Ä’´ ‘±÷Ä’ø’°’Æ’∏÷Ç’¥</h3>
            <div class="formula-box">
                <p><strong>‘ø’∏’≤’¥’∂’°’µ’´’∂ ’Ñ’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’´ ’Ñ’°’Ø’•÷Ä’•’Ω.</strong> ‘¥’´’ø’°÷Ä’Ø’æ’∏÷Ç’¥ ’ß ’∏÷Ä’∫’•’Ω ’¥’•’Æ ÷á ÷É’∏÷Ñ÷Ä ’Ø’∏’∂’∂’•÷Ä’´ ’Ø’∏’≤’¥’∂’°’µ’´’∂ ’¥’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’∂’•÷Ä’´ ’ø’°÷Ä’¢’•÷Ä’∏÷Ç’©’µ’∏÷Ç’∂: <br> $$ S_{k} = \\pi (R + r) l $$</p>
                <p><strong>‘º÷Ä’´’æ ’Ñ’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’´ ’Ñ’°’Ø’•÷Ä’•’Ω.</strong> $$ S_{l} = S_{k} + \\pi R^2 + \\pi r^2 $$</p>
                <p><strong>‘æ’°’æ’°’¨.</strong> $$ V = \\frac{1}{3}\\pi H (R^2 + r^2 + Rr) $$</p>
            </div>
        </div>

        <!-- 4. SPHERE -->
        <div class="theory-block">
            <h2>4. ‘≥’∏÷Ç’∂’§ ÷á ‘≥’∂’§’°’µ’´’∂ ’Ñ’°’Ø’•÷Ä÷á’∏÷Ç’µ’© (Sphere)</h2>
            <p><strong>’ç’°’∞’¥’°’∂’∏÷Ç’¥.</strong> <em>‘≥’∂’§’°’µ’´’∂ ’¥’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’® (’Ω÷Ü’•÷Ä’°)</em> ’ø’°÷Ä’°’Æ’∏÷Ç’©’µ’°’∂ ’°’µ’∂ ’¢’∏’¨’∏÷Ä ’Ø’•’ø’•÷Ä’´ ’¢’°’¶’¥’∏÷Ç’©’µ’∏÷Ç’∂’∂ ’ß, ’∏÷Ä’∏’∂÷Ñ ’£’ø’∂’æ’∏÷Ç’¥ ’•’∂ ’ø÷Ä’æ’°’Æ ’Ø’•’ø’´÷Å (’Ø’•’∂’ø÷Ä’∏’∂) ’ø÷Ä’æ’°’Æ ’∞’•’º’°’æ’∏÷Ä’∏÷Ç’©’µ’°’∂ (’∑’°’º’°’æ’´’≤) ’æ÷Ä’°: <em>‘≥’∏÷Ç’∂’§’®</em> ’°’µ’∂ ’¥’°÷Ä’¥’´’∂’∂ ’ß, ’∏÷Ä’® ’Ω’°’∞’¥’°’∂’°÷É’°’Ø’æ’°’Æ ’ß ’£’∂’§’°’µ’´’∂ ’¥’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’∏’æ ÷á ’∂’•÷Ä’°’º’∏÷Ç’¥ ’ß ’ø’°÷Ä’°’Æ’∏÷Ç’©’µ’°’∂ ’¢’∏’¨’∏÷Ä ’°’µ’∂ ’Ø’•’ø’•÷Ä’®, ’∏÷Ä’∏’∂÷Å ’∞’•’º’°’æ’∏÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’® ’Ø’•’∂’ø÷Ä’∏’∂’´÷Å ÷É’∏÷Ñ÷Ä ’ß ’Ø’°’¥ ’∞’°’æ’°’Ω’°÷Ä ’∑’°’º’°’æ’≤’´’∂ (‚â§ R)÷â </p>

            <h3>’Ä’°’ø’Ø’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä</h3>
            <ul>
                <li><strong>’Ä’°’ø’∏÷Ç’µ’©’∂’•÷Ä.</strong> ‘≥’∂’§’´ ÷Å’°’∂’Ø’°÷Å’°’Æ ’∞’°’ø’∏÷Ç’µ’© ’∞’°÷Ä’©’∏÷Ç’©’µ’°’¥’¢ ’∑÷Ä’ª’°’∂ ’ß: ‘µ’©’• ’∞’°÷Ä’©’∏÷Ç’©’µ’∏÷Ç’∂’® ’°’∂÷Å’∂’∏÷Ç’¥ ’ß ’Ø’•’∂’ø÷Ä’∏’∂’∏’æ, ’∞’°’ø’∏÷Ç’µ’©’® ’Ø’∏’π’æ’∏÷Ç’¥ ’ß <em>’Ñ’•’Æ ’∑÷Ä’ª’°’∂</em>, ’∞’°’Ø’°’º’°’Ø ’§’•’∫÷Ñ’∏÷Ç’¥’ù <em>’ì’∏÷Ñ÷Ä ’∑÷Ä’ª’°’∂</em>÷â</li>
                <li><strong>’á’∏’∑’°÷É’∏’≤ ’∞’°÷Ä’©’∏÷Ç’©’µ’∏÷Ç’∂.</strong> ’à÷Ç’≤’≤’°’∞’°’µ’°÷Å ’ß ’∑’∏’∑’°÷É’¥’°’∂ ’Ø’•’ø ’ø’°÷Ä’æ’°’Æ ’∑’°’º’°’æ’≤’´’∂:</li>
            </ul>

            <div class="formula-box">
                <p><strong>’Ñ’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’´ ’Ñ’°’Ø’•÷Ä’•’Ω.</strong> ’Ä’°’æ’°’Ω’°÷Ä ’ß ’¥’•’Æ ’∑÷Ä’ª’°’∂’´ ÷Ñ’°’º’°’∫’°’ø’´’Ø ’¥’°’Ø’•÷Ä’•’Ω’´’∂: <br> $$ S = 4\\pi R^2 $$</p>
                <p><strong>‘æ’°’æ’°’¨.</strong> $$ V = \\frac{4}{3}\\pi R^3 $$</p>
            </div>
            
            <h3>‘≥’∂’§’´ ’Ñ’°’Ω’•÷Ä’®</h3>
            
            <div class="sub-theory">
                <h4>’°) ‘≥’∂’§’°’µ’´’∂ ’ç’•’£’¥’•’∂’ø (Spherical Segment)</h4>
                <p>‘≥’∂’§’´ ’°’µ’∂ ’¥’°’Ω’®, ’∏÷Ä’∂ ’°’º’°’ª’°’∂’∏÷Ç’¥ ’ß ’£’∏÷Ç’∂’§’® ’∞’°÷Ä’©’∏÷Ç’©’µ’°’¥’¢ ’∞’°’ø’•’¨’´’Ω÷â ’Ö’∏÷Ç÷Ä’°÷Ñ’°’∂’π’µ’∏÷Ç÷Ä ’∞’°’ø’∏÷Ç’¥ ’Ω’ø’•’≤’Æ’∏÷Ç’¥ ’ß ’•÷Ä’Ø’∏÷Ç ’Ω’•’£’¥’•’∂’ø÷â</p>
                <div class="formula-box">
                    <p><strong>’Ñ’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’´ ’Ñ’°’Ø’•÷Ä’•’Ω.</strong> ‘ø’°’≠’æ’°’Æ ’ß ’¥’´’°’µ’∂ ’Ω’•’£’¥’•’∂’ø’´ $h$ ’¢’°÷Ä’±÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’´÷Å ÷á ’£’∂’§’´ $R$ ’∑’°’º’°’æ’≤’´÷Å: <br> $$ S_{k} = 2\\pi R h $$</p>
                    <p><strong>‘æ’°’æ’°’¨.</strong> $$ V = \\pi h^2 (R - \\frac{h}{3}) $$</p>
                </div>
            </div>

            <div class="sub-theory">
                <h4>’¢) ‘≥’∂’§’°’µ’´’∂ ’ç’•’Ø’ø’∏÷Ä (Spherical Sector)</h4>
                <p>’Ñ’°÷Ä’¥’´’∂, ’∏÷Ä’® ’Ω’ø’°÷Å’æ’∏÷Ç’¥ ’ß ’£’∂’§’°’µ’´’∂ ’Ω’•’£’¥’•’∂’ø’´÷Å ÷á ’°’µ’∂ ’Ø’∏’∂’´÷Å, ’∏÷Ä’´ ’£’°’£’°’©’® ’£’∂’§’´ ’Ø’•’∂’ø÷Ä’∏’∂’∂ ’ß, ’´’Ω’Ø ’∞’´’¥÷Ñ’®’ù ’Ω’•’£’¥’•’∂’ø’´ ’∞’´’¥÷Ñ’®:</p>
                <div class="formula-box">
                    <p><strong>‘æ’°’æ’°’¨.</strong> ’Ä’°’æ’°’Ω’°÷Ä ’ß ’Ω’•’Ø’ø’∏÷Ä’´ ’¥’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’´ (’Ω’•’£’¥’•’∂’ø’´ ’¥’°’Ω’´) ÷á ’£’∂’§’´ ’∑’°’º’°’æ’≤’´ ’°÷Ä’ø’°’§÷Ä’µ’°’¨’´ ’¥’•’Ø ’•÷Ä÷Ä’∏÷Ä’§’´’∂: <br> $$ V = \\frac{2}{3}\\pi R^2 h $$</p>
                </div>
            </div>

            <div class="sub-theory">
                <h4>’£) ‘≥’∂’§’°’µ’´’∂ ’á’•÷Ä’ø (Spherical Layer)</h4>
                <p>‘≥’∂’§’´ ’°’µ’∂ ’¥’°’Ω’®, ’∏÷Ä’® ’∫’°÷Ä÷É’°’Ø’æ’°’Æ ’ß ’•÷Ä’Ø’∏÷Ç ’¶’∏÷Ç’£’°’∞’•’º ’∞’°÷Ä’©’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä’´ ’¥’´’ª÷á:</p>
                <div class="formula-box">
                    <p><strong>‘ø’∏’≤’¥’∂’°’µ’´’∂ ’Ñ’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’´ ’Ñ’°’Ø’•÷Ä’•’Ω (‘≥’∂’§’°’µ’´’∂ ’£’∏’ø’´).</strong> $$ S_{k} = 2\\pi R h $$</p>
                    <p><strong>‘æ’°’æ’°’¨.</strong> $$ V = \\frac{1}{6}\\pi h (3r_1^2 + 3r_2^2 + h^2) $$</p>
                </div>
            </div>

            <div class="sub-theory">
                <h4>’§) ‘≥’∂’§’°’µ’´’∂ ‘≥’∏’ø’´ (Spherical Cap)</h4>
                <p>‘≥’∂’§’°’µ’´’∂ ’¥’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’´ ’°’µ’∂ ’¥’°’Ω’®, ’∏÷Ä’® ’£’ø’∂’æ’∏÷Ç’¥ ’ß ’•÷Ä’Ø’∏÷Ç ’¶’∏÷Ç’£’°’∞’•’º ’∞’°’ø’∏’≤ ’∞’°÷Ä’©’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä’´ ’¥’´’ª÷á÷â</p>
                <div class="formula-box">
                    <p><strong>’Ñ’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’´ ’Ñ’°’Ø’•÷Ä’•’Ω.</strong> $$ S_{k} = 2\\pi R h $$</p>
                </div>
            </div>
        </div>
    `,
    ru: `
        <!-- 1. –¶–∏–ª–∏–Ω–¥—Ä -->
        <div class="theory-block">
            <h2>1. –¶–∏–ª–∏–Ω–¥—Ä</h2>
            <p><strong>–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ.</strong> –ü—Ä—è–º–æ–π –∫—Ä—É–≥–æ–≤–æ–π —Ü–∏–ª–∏–Ω–¥—Ä ‚Äî —Ç–µ–ª–æ, –ø–æ–ª—É—á–∞—é—â–µ–µ—Å—è –ø—Ä–∏ –≤—Ä–∞—â–µ–Ω–∏–∏ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞ –≤–æ–∫—Ä—É–≥ –æ–¥–Ω–æ–π –∏–∑ –µ–≥–æ —Å—Ç–æ—Ä–æ–Ω (–æ—Å–∏).</p>
            <h3>–û—Å–Ω–æ–≤–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –∏ —Å–≤–æ–π—Å—Ç–≤–∞</h3>
            <ul>
                <li><strong>–û—Å–Ω–æ–≤–∞–Ω–∏—è.</strong> –î–≤–∞ —Ä–∞–≤–Ω—ã—Ö –∏ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö –∫—Ä—É–≥–∞, —Ü–µ–Ω—Ç—Ä—ã –∫–æ—Ç–æ—Ä—ã—Ö –ª–µ–∂–∞—Ç –Ω–∞ –æ—Å–∏ —Ü–∏–ª–∏–Ω–¥—Ä–∞.</li>
                <li><strong>–û–±—Ä–∞–∑—É—é—â–∏–µ.</strong> –û—Ç—Ä–µ–∑–∫–∏, —Å–æ–µ–¥–∏–Ω—è—é—â–∏–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ —Ç–æ—á–∫–∏ –∫—Ä—É–≥–æ–≤; –æ–Ω–∏ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã –æ—Å–∏ –∏ —Ä–∞–≤–Ω—ã –º–µ–∂–¥—É —Å–æ–±–æ–π (–≤—ã—Å–æ—Ç–∞ H).</li>
                <li><strong>–°–µ—á–µ–Ω–∏–µ —á–µ—Ä–µ–∑ –æ—Å—å.</strong> –ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫.</li>
            </ul>
            <div class="formula-box">
                <p><strong>–ü–ª–æ—â–∞–¥—å –±–æ–∫–æ–≤–æ–π –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏:</strong> $$ S_{k} = 2\\pi R H $$</p>
                <p><strong>–ü–æ–ª–Ω–∞—è –ø–ª–æ—â–∞–¥—å –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏:</strong> $$ S_{l} = 2\\pi R(H+R) $$</p>
                <p><strong>–û–±—ä–µ–º:</strong> $$ V = \\pi R^2 H $$</p>
            </div>
        </div>

        <!-- 2. –ö–æ–Ω—É—Å -->
        <div class="theory-block">
            <h2>2. –ö–æ–Ω—É—Å</h2>
            <p><strong>–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ.</strong> –ü—Ä—è–º–æ–π –∫–æ–Ω—É—Å –ø–æ–ª—É—á–∞–µ—Ç—Å—è –ø—Ä–∏ –≤—Ä–∞—â–µ–Ω–∏–∏ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–æ–≥–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ –≤–æ–∫—Ä—É–≥ –æ–¥–Ω–æ–≥–æ –∏–∑ –∫–∞—Ç–µ—Ç–æ–≤; –≤–µ—Ä—à–∏–Ω–∞ –∫–æ–Ω—É—Å–∞ ‚Äî —Ç–æ—á–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –æ–±—Ä–∞–∑—É—é—â–∏—Ö.</p>
            <h3>–≠–ª–µ–º–µ–Ω—Ç—ã</h3>
            <ul>
                <li><strong>–û–±—Ä–∞–∑—É—é—â–∞—è (l).</strong> –û—Ç—Ä–µ–∑–æ–∫ –æ—Ç –≤–µ—Ä—à–∏–Ω—ã –¥–æ —Ç–æ—á–∫–∏ –æ—Å–Ω–æ–≤–∞–Ω–∏—è; –¥–ª—è –ø—Ä—è–º–æ–≥–æ –∫–æ–Ω—É—Å–∞ –≤—Å–µ –æ–±—Ä–∞–∑—É—é—â–∏–µ —Ä–∞–≤–Ω—ã.</li>
                <li><strong>–°–µ—á–µ–Ω–∏–µ —á–µ—Ä–µ–∑ –æ—Å—å.</strong> –†–∞–≤–Ω–æ–±–µ–¥—Ä–µ–Ω–Ω—ã–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫.</li>
            </ul>
            <div class="formula-box">
                <p><strong>–°–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ (–ü–∏—Ñ–∞–≥–æ—Ä):</strong> $$ l^2 = R^2 + H^2 $$</p>
                <p><strong>–ü–ª–æ—â–∞–¥—å –±–æ–∫–æ–≤–æ–π –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏:</strong> $$ S_{k} = \\pi R l $$</p>
                <p><strong>–ü–æ–ª–Ω–∞—è –ø–ª–æ—â–∞–¥—å –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏:</strong> $$ S_{l} = \\pi R (l + R) $$</p>
                <p><strong>–û–±—ä–µ–º:</strong> $$ V = \\frac{1}{3}\\pi R^2 H $$</p>
            </div>
        </div>

        <!-- 3. –£—Å–µ—á—ë–Ω–Ω—ã–π –∫–æ–Ω—É—Å -->
        <div class="theory-block">
            <h2>3. –£—Å–µ—á—ë–Ω–Ω—ã–π –∫–æ–Ω—É—Å</h2>
            <p><strong>–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ.</strong> –ß–∞—Å—Ç—å –∫–æ–Ω—É—Å–∞, –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–∞—è –¥–≤—É–º—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–º–∏ –ø–ª–æ—Å–∫–æ—Å—Ç—è–º–∏ (–∏–ª–∏ –æ—Å–Ω–æ–≤–∞–Ω–∏–µ–º –∏ –ø–ª–æ—Å–∫–æ—Å—Ç—å—é, –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–π –æ—Å–Ω–æ–≤–∞–Ω–∏—é).</p>
            <div class="formula-box">
                <p><strong>–ü–ª–æ—â–∞–¥—å –±–æ–∫–æ–≤–æ–π –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏:</strong> $$ S_{k} = \\pi (R + r) l $$</p>
                <p><strong>–ü–æ–ª–Ω–∞—è –ø–ª–æ—â–∞–¥—å –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏:</strong> $$ S_{l} = \\pi (R + r) l + \\pi R^2 + \\pi r^2 $$</p>
                <p><strong>–û–±—ä–µ–º:</strong> $$ V = \\frac{1}{3}\\pi H (R^2 + r^2 + Rr) $$</p>
            </div>
        </div>

        <!-- 4. –°—Ñ–µ—Ä–∞ –∏ —à–∞—Ä -->
        <div class="theory-block">
            <h2>4. –°—Ñ–µ—Ä–∞ –∏ —à–∞—Ä</h2>
            <p><strong>–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ.</strong> –°—Ñ–µ—Ä–∞ ‚Äî –º–Ω–æ–∂–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫, —Ä–∞–≤–Ω–æ—É–¥–∞–ª—ë–Ω–Ω—ã—Ö –æ—Ç —Ü–µ–Ω—Ç—Ä–∞ –Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ R; —à–∞—Ä ‚Äî —Ç–µ–ª–æ, –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–µ —Å—Ñ–µ—Ä–æ–π.</p>
            <div class="formula-box">
                <p><strong>–ü–ª–æ—â–∞–¥—å –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏:</strong> $$ S = 4\\pi R^2 $$</p>
                <p><strong>–û–±—ä–µ–º:</strong> $$ V = \\frac{4}{3}\\pi R^3 $$</p>
            </div>

            <h3>–ß–∞—Å—Ç–∏ —à–∞—Ä–∞</h3>
            <div class="sub-theory">
                <h4>–∞) –°—Ñ–µ—Ä–∏—á–µ—Å–∫–∏–π —Å–µ–≥–º–µ–Ω—Ç</h4>
                <p>–ß–∞—Å—Ç—å —à–∞—Ä–∞, –æ—Ç—Å–µ–∫–∞–µ–º–∞—è —Å–µ–∫—É—â–µ–π –ø–ª–æ—Å–∫–æ—Å—Ç—å—é; —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏–∑—É–µ—Ç—Å—è –≤—ã—Å–æ—Ç–æ–π —Å–µ–≥–º–µ–Ω—Ç–∞ h.</p>
                <div class="formula-box">
                    <p><strong>–ë–æ–∫–æ–≤–∞—è –ø–ª–æ—â–∞–¥—å (–ø–æ–ª–æ—Å–∞):</strong> $$ S_{k} = 2\\pi R h $$</p>
                    <p><strong>–ü–æ–ª–Ω–∞—è –ø–ª–æ—â–∞–¥—å:</strong> $$ S_{l} = 2\\pi R h + \\pi r^2 $$</p>
                    <p><strong>–û–±—ä–µ–º:</strong> $$ V = \\pi h^2 (R - \\frac{h}{3}) $$</p>
                </div>
            </div>

            <div class="sub-theory">
                <h4>–±) –°—Ñ–µ—Ä–∏—á–µ—Å–∫–∏–π —Å–µ–∫—Ç–æ—Ä</h4>
                <p>–°–æ—Å—Ç–æ–∏—Ç –∏–∑ —Å–µ–≥–º–µ–Ω—Ç–∞ –∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–≥–æ –∫–æ–Ω—É—Å–∞, –æ–±—Ä–∞–∑–æ–≤–∞–Ω–Ω–æ–≥–æ —Ü–µ–Ω—Ç—Ä–æ–º —Å—Ñ–µ—Ä—ã.</p>
                <div class="formula-box">
                    <p><strong>–û–±—ä–µ–º:</strong> $$ V = \\frac{2}{3}\\pi R^2 h $$</p>
                </div>
            </div>

            <div class="sub-theory">
                <h4>–≤) –°—Ñ–µ—Ä–∏—á–µ—Å–∫–∞—è –ø–æ–ª–æ—Å–∞ (—Å–ª–æ–π)</h4>
                <p>–ß–∞—Å—Ç—å —à–∞—Ä–∞ –º–µ–∂–¥—É –¥–≤—É–º—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–º–∏ –ø–ª–æ—Å–∫–æ—Å—Ç—è–º–∏.</p>
                <div class="formula-box">
                    <p><strong>–ë–æ–∫–æ–≤–∞—è –ø–ª–æ—â–∞–¥—å:</strong> $$ S_{k} = 2\\pi R h $$</p>
                    <p><strong>–û–±—ä–µ–º:</strong> $$ V = \\frac{1}{6}\\pi h (3r_1^2 + 3r_2^2 + h^2) $$</p>
                </div>
            </div>
        </div>
    `,
    en: `
        <!-- 1. Cylinder -->
        <div class="theory-block">
            <h2>1. Cylinder</h2>
            <p><strong>Definition.</strong> A right circular cylinder is the solid obtained by rotating a rectangle around one of its sides (the axis).</p>
            <h3>Main elements and properties</h3>
            <ul>
                <li><strong>Bases.</strong> Two equal parallel circles; their centers lie on the axis.</li>
                <li><strong>Generatrices.</strong> Line segments joining corresponding points on the circles; they are parallel to the axis and equal (height H).</li>
                <li><strong>Axial section.</strong> A rectangle through the axis.</li>
            </ul>
            <div class="formula-box">
                <p><strong>Lateral surface area:</strong> $$ S_{k} = 2\\pi R H $$</p>
                <p><strong>Total surface area:</strong> $$ S_{l} = 2\\pi R(H+R) $$</p>
                <p><strong>Volume:</strong> $$ V = \\pi R^2 H $$</p>
            </div>
        </div>

        <!-- 2. Cone -->
        <div class="theory-block">
            <h2>2. Cone</h2>
            <p><strong>Definition.</strong> A right circular cone is formed by rotating a right triangle about one of its legs; the slant (l) is the length of the generatrix.</p>
            <div class="formula-box">
                <p><strong>Relation (Pythagoras):</strong> $$ l^2 = R^2 + H^2 $$</p>
                <p><strong>Lateral surface area:</strong> $$ S_{k} = \\pi R l $$</p>
                <p><strong>Total surface area:</strong> $$ S_{l} = \\pi R (l + R) $$</p>
                <p><strong>Volume:</strong> $$ V = \\frac{1}{3}\\pi R^2 H $$</p>
            </div>
        </div>

        <!-- 3. Frustum -->
        <div class="theory-block">
            <h2>3. Frustum</h2>
            <p><strong>Definition.</strong> The frustum of a cone is the portion between two parallel planes cutting the cone (or between the base and a plane parallel to it).</p>
            <div class="formula-box">
                <p><strong>Lateral surface area:</strong> $$ S_{k} = \\pi (R + r) l $$</p>
                <p><strong>Total surface area:</strong> $$ S_{l} = \\pi (R + r) l + \\pi R^2 + \\pi r^2 $$</p>
                <p><strong>Volume:</strong> $$ V = \\frac{1}{3}\\pi H (R^2 + r^2 + Rr) $$</p>
            </div>
        </div>

        <!-- 4. Sphere -->
        <div class="theory-block">
            <h2>4. Sphere and Ball</h2>
            <p><strong>Definition.</strong> A sphere is the set of points at a fixed distance (radius) from a center; a ball is the solid bounded by the sphere.</p>
            <div class="formula-box">
                <p><strong>Surface area:</strong> $$ S = 4\\pi R^2 $$</p>
                <p><strong>Volume:</strong> $$ V = \\frac{4}{3}\\pi R^3 $$</p>
            </div>

            <h3>Spherical parts</h3>
            <div class="sub-theory">
                <h4>a) Spherical segment</h4>
                <p>The portion of a sphere cut off by a plane; described by segment height h.</p>
                <div class="formula-box">
                    <p><strong>Lateral area (zone):</strong> $$ S_{k} = 2\\pi R h $$</p>
                    <p><strong>Total area:</strong> $$ S_{l} = 2\\pi R h + \\pi r^2 $$</p>
                    <p><strong>Volume:</strong> $$ V = \\pi h^2 (R - \\frac{h}{3}) $$</p>
                </div>
            </div>

            <div class="sub-theory">
                <h4>b) Spherical sector</h4>
                <p>Formed by a spherical segment together with the cone having the sphere center as vertex.</p>
                <div class="formula-box">
                    <p><strong>Volume:</strong> $$ V = \\frac{2}{3}\\pi R^2 h $$</p>
                </div>
            </div>

            <div class="sub-theory">
                <h4>c) Spherical layer</h4>
                <p>The part of a sphere between two parallel planes.</p>
                <div class="formula-box">
                    <p><strong>Lateral area:</strong> $$ S_{k} = 2\\pi R h $$</p>
                    <p><strong>Total area:</strong> $$ S_{l} = 2\\pi R h + \\pi r_1^2 + \\pi r_2^2 $$</p>
                    <p><strong>Volume:</strong> $$ V = \\frac{1}{6}\\pi h (3r_1^2 + 3r_2^2 + h^2) $$</p>
                </div>
            </div>
        </div>
    `
};

// --- Translations (UI Elements) ---
const translations = {
    hy: {
        nav_theory: "’è’•’Ω’∏÷Ç’©’µ’∏÷Ç’∂",
        nav_apps: "‘ø’´÷Ä’°’º’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä",
        nav_calc: "’Ä’°’∑’æ’´’π",
        nav_calc: "’Ä’°’∑’æ’´’π",
        nav_models: "’Ñ’∏’§’•’¨’∂’•÷Ä",
        nav_sphere: "üåê ‘≥’∏÷Ç’∂’§",
        theory_title: "’ä’ø’ø’°’Ø’°’∂ ’Ñ’°÷Ä’¥’´’∂’∂’•÷Ä",
        theory_intro: "’ä’ø’ø’°’Ø’°’∂ ’¥’°÷Ä’¥’´’∂’∂’•÷Ä’® ’•÷Ä’Ø÷Ä’°’π’°÷É’∏÷Ç’©’µ’°’∂ ’∞’´’¥’∂’°’Ω’µ’∏÷Ç’∂’•÷Ä’´÷Å ’•’∂...",
        apps_title: "’ï’∫’ø’´’¥’°’¨ ‘ø’´÷Ä’°’º’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä ‘ø’µ’°’∂÷Ñ’∏÷Ç’¥",
        apps_intro: "‘ª’∂’π’∏÷Ç’û ’•’∂ ’°’º÷Ö÷Ä’µ’° ’´÷Ä’•÷Ä’® ’∞’•’∂÷Å ’°’µ’Ω’∫’´’Ω’´’∂?",
        calc_title: "‘Ω’•’¨’°÷Å’´ ’Ä’°’∑’æ’´’π",
        calc_select: "‘∏’∂’ø÷Ä’•÷Ñ ’Ñ’°÷Ä’¥’´’∂’®.",
        btn_calc: "’Ä’°’∑’æ’•’¨",
        model_lab: "3D ‘º’°’¢’∏÷Ä’°’ø’∏÷Ä’´’°",
        model_shape: "’Ñ’°÷Ä’¥’´’∂:",
        model_color: "‘≥’∏÷Ç’µ’∂:",
        model_mode: "’å’•’™’´’¥:",
        btn_wireframe: "’ë’°’∂÷Å’°’µ’´’∂ / ’Ä’∏’Æ",
        model_slice: "’Ä’°’ø’∏÷Ç’¥:",
        model_move: "’è’•’≤’°’∑’°÷Ä’™:",
        opt_cyl: "‘≥’¨’°’∂",
        opt_cone: "‘ø’∏’∂",
        opt_frustum: "’Ä’°’ø’°’Æ ‘ø’∏’∂",
        opt_sphere: "‘≥’∏÷Ç’∂’§",
        opt_segment: "‘≥’∂’§’°’µ’´’∂ ’ç’•’£’¥’•’∂’ø",
        opt_sector: "‘≥’∂’§’°’µ’´’∂ ’ç’•’Ø’ø’∏÷Ä",
        opt_layer: "‘≥’∂’§’°’µ’´’∂ ’á’•÷Ä’ø",
        opt_zone: "‘≥’∂’§’°’µ’´’∂ ‘≥’∏’ø’´",
        info_slant: "‘æ’∂’∏÷Ä’§ (l):",
        info_side_area: "$S_k$: ",
        info_total_area: "$S_l$: ",
        info_volume: "$V$: ",
        info_surface: "’Ñ’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’´ ’¥’°’Ø’•÷Ä’•’Ω:"
        ,
        footer_copy: "&copy; 2025 ¬´’ä’ø’ø’°’Ø’°’∂ ’Ñ’°÷Ä’¥’´’∂’∂’•÷Ä¬ª ’Ü’°’≠’°’£’´’Æ. ‘≤’∏’¨’∏÷Ä ’´÷Ä’°’æ’∏÷Ç’∂÷Ñ’∂’•÷Ä’® ’∫’°’∑’ø’∫’°’∂’æ’°’Æ ’•’∂.",
        footer_created: "’ç’ø’•’≤’Æ’æ’°’Æ ’ß ‘ø’°÷Ä’•’∂ ’ä’∏’≤’∏’Ω’µ’°’∂’´ ÷á ‘≥÷Ä’´’∑’° ‘Ω’∏÷Ç’¥’°÷Ä’µ’°’∂’´ ’Ø’∏’≤’¥’´÷Å"
    },
    ru: {
        nav_theory: "–¢–µ–æ—Ä–∏—è",
        nav_apps: "–ü—Ä–∏–º–µ–Ω–µ–Ω–∏—è",
        nav_calc: "–ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä",
        nav_calc: "–ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä",
        nav_models: "–ú–æ–¥–µ–ª–∏",
        nav_sphere: "üåê –°—Ñ–µ—Ä–∞",
        theory_title: "–¢–µ–ª–∞ –í—Ä–∞—â–µ–Ω–∏—è",
        theory_intro: "–¢–µ–ª–∞ –≤—Ä–∞—â–µ–Ω–∏—è ‚Äî –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–µ –æ–±—ä–µ–∫—Ç—ã –≥–µ–æ–º–µ—Ç—Ä–∏–∏ –∏ —Ñ–∏–∑–∏–∫–∏...",
        apps_title: "–û–ø—Ç–∏–º–∞–ª—å–Ω—ã–µ –ü—Ä–∏–º–µ–Ω–µ–Ω–∏—è",
        apps_intro: "–ü–æ—á–µ–º—É –ø–æ–≤—Å–µ–¥–Ω–µ–≤–Ω—ã–µ –≤–µ—â–∏ –≤—ã–≥–ª—è–¥—è—Ç –∏–º–µ–Ω–Ω–æ —Ç–∞–∫?",
        calc_title: "–£–º–Ω—ã–π –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä",
        calc_select: "–í—ã–±–µ—Ä–∏—Ç–µ –§–∏–≥—É—Ä—É.",
        btn_calc: "–†–∞—Å—Å—á–∏—Ç–∞—Ç—å",
        model_lab: "3D –õ–∞–±–æ—Ä–∞—Ç–æ—Ä–∏—è",
        model_shape: "–§–∏–≥—É—Ä–∞:",
        model_color: "–¶–≤–µ—Ç:",
        model_mode: "–†–µ–∂–∏–º:",
        btn_wireframe: "–ö–∞—Ä–∫–∞—Å / –°–ø–ª–æ—à–Ω–æ–π",
        model_slice: "–°–µ—á–µ–Ω–∏–µ:",
        model_move: "–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ:",
        opt_cyl: "–¶–∏–ª–∏–Ω–¥—Ä",
        opt_cone: "–ö–æ–Ω—É—Å",
        opt_frustum: "–£—Å–µ—á–µ–Ω–Ω—ã–π –ö–æ–Ω—É—Å",
        opt_sphere: "–°—Ñ–µ—Ä–∞",
        opt_segment: "–°—Ñ–µ—Ä–∏—á–µ—Å–∫–∏–π –°–µ–≥–º–µ–Ω—Ç",
        opt_sector: "–°—Ñ–µ—Ä–∏—á–µ—Å–∫–∏–π –°–µ–∫—Ç–æ—Ä",
        opt_layer: "–°—Ñ–µ—Ä–∏—á–µ—Å–∫–∏–π –°–ª–æ–π",
        opt_zone: "–°—Ñ–µ—Ä–∏—á–µ—Å–∫–∏–π –ü–æ—è—Å",
        info_slant: "–û–±—Ä–∞–∑—É—é—â–∞—è (l):",
        info_side_area: "$S_k$: ",
        info_total_area: "$S_l$: ",
        info_volume: "$V$: ",
        info_surface: "–ü–ª–æ—â–∞–¥—å –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏:"
        ,
        footer_copy: '&copy; 2025 –ü—Ä–æ–µ–∫—Ç "–¢–µ–ª–∞ –í—Ä–∞—â–µ–Ω–∏—è". –í—Å–µ –ø—Ä–∞–≤–∞ –∑–∞—â–∏—â–µ–Ω—ã.',
        footer_created: "–°–æ–∑–¥–∞–Ω–æ: –ö–∞—Ä–µ–Ω –ü–æ–≥–æ—Å—è–Ω –∏ –ì—Ä–∏—à–∞ –•—É–º–∞—Ä—è–Ω"
    },
    en: {
        nav_theory: "Theory",
        nav_apps: "Applications",
        nav_calc: "Calculator",
        nav_calc: "Calculator",
        nav_models: "Models",
        nav_sphere: "üåê Sphere",
        theory_title: "Solids of Revolution",
        theory_intro: "Solids of revolution are fundamental geometric objects...",
        apps_title: "Optimal Applications",
        apps_intro: "Why do everyday objects look like this?",
        calc_title: "Smart Calculator",
        calc_select: "Select Shape.",
        btn_calc: "Calculate",
        model_lab: "3D Laboratory",
        model_shape: "Shape:",
        model_color: "Color:",
        model_mode: "Mode:",
        btn_wireframe: "Wireframe / Solid",
        model_slice: "Slicing:",
        model_move: "Move:",
        opt_cyl: "Cylinder",
        opt_cone: "Cone",
        opt_frustum: "Frustum",
        opt_sphere: "Sphere",
        opt_segment: "Spherical Segment",
        opt_sector: "Spherical Sector",
        opt_layer: "Spherical Layer",
        opt_zone: "Spherical Zone",
        info_slant: "Slant (l):",
        info_side_area: "$S_k$: ",
        info_total_area: "$S_l$: ",
        info_volume: "$V$: ",
        info_surface: "Surface Area:"
        ,
        footer_copy: '&copy; 2025 "Rotational Solids" Project. All Rights Reserved.',
        footer_created: "Created by Karen Poghosyan and Grisha Khumaryan"
    }
};

let currentLang = 'hy';

// --- Navigation Logic ---
window.showPage = function (pageId) {
    if (pageId === 'sphere_link') {
        window.location.href = 'index.html';
        return;
    }
    document.querySelectorAll('.page').forEach(p => {
        p.classList.remove('active');
        p.style.display = 'none';
    });
    const activePage = document.getElementById(pageId);
    if (activePage) {
        activePage.classList.add('active');
        activePage.style.display = 'block';
    }
    if (pageId === 'models') {
        setTimeout(() => {
            const container = document.getElementById('canvas-container');
            if (camera && renderer && container) {
                const w = Math.max(240, container.clientWidth || window.innerWidth);
                const h = Math.max(240, container.clientHeight || (window.innerHeight - 140));
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h);
            }
        }, 100);
    }
};

// --- Language Logic ---
window.setLang = function (lang) {
    currentLang = lang;

    // Remove active class from language buttons - no longer needed as buttons replaced by dropdown

    // Sync dropdown selected option if it exists
    const langSelect = document.getElementById('langSelect');
    if (langSelect) {
        langSelect.value = lang;
    }

    document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (translations[lang][key]) {
            if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                el.placeholder = translations[lang][key];
            } else {
                el.innerHTML = translations[lang][key];
            }
        }
    });

    const theoryContainer = document.getElementById('theory-content');
    if (theoryContainer) {
        // Sanitize theory HTML to remove any accidental injected tokens like "info_slant:"
        let raw = theoryContent[lang] || theoryContent['hy'];
        raw = raw.replace(/\binfo_[a-zA-Z0-9_]*\s*:\s*"[^"]*"\s*,?/g, '');
        theoryContainer.innerHTML = raw;
    }

    renderApps();

    if (window.MathJax) {
        MathJax.typesetPromise();
    }

    // Update mobile nav dropdown and page padding after language change
    if (window.populateMobileNav) populateMobileNav();
    if (window.adjustPagePadding) adjustPagePadding();
};

// Toggle Mobile Menu
window.toggleMobileMenu = function () {
    const overlay = document.getElementById('mobileMenuOverlay');
    if (overlay) {
        overlay.classList.toggle('active');
    }
};

// Populate mobile nav list with localized labels
function populateMobileNav() {
    const list = document.getElementById('mobileMenuLinks');
    if (!list) return;
    list.innerHTML = '';

    // Define items with icons for better look
    const items = [
        { id: 'sphere_link', key: 'nav_sphere', icon: 'fa-globe' },
        { id: 'theory', key: 'nav_theory', icon: 'fa-book' },
        { id: 'applications', key: 'nav_apps', icon: 'fa-rocket' },
        { id: 'calculator', key: 'nav_calc', icon: 'fa-calculator' },
        { id: 'models', key: 'nav_models', icon: 'fa-cube' }
    ];

    items.forEach(item => {
        const li = document.createElement('li');
        const text = (translations[currentLang] && translations[currentLang][item.key]) ? translations[currentLang][item.key] : translations['en'][item.key];

        li.innerHTML = `<i class="fas ${item.icon}"></i> ${text}`;
        li.onclick = () => {
            showPage(item.id);
            toggleMobileMenu();
        };
        list.appendChild(li);
    });
}

// Adjust page top padding to account for navbar height (prevents overlap on mobile)
function adjustPagePadding() {
    const nav = document.querySelector('.navbar');
    if (!nav) return;
    const h = Math.ceil(nav.getBoundingClientRect().height);
    document.querySelectorAll('.page').forEach(p => {
        p.style.paddingTop = (h + 16) + 'px';
    });
}

// --- Theme Logic ---
window.toggleTheme = function () {
    const html = document.documentElement;
    const current = html.getAttribute('data-theme');
    const next = current === 'light' ? 'dark' : 'light';
    html.setAttribute('data-theme', next);

    const icon = document.querySelector('.theme-btn i');
    icon.className = next === 'light' ? 'fas fa-moon' : 'fas fa-sun';

    // If on models page, re-init 3D to update grid color
    if (document.getElementById('models') && document.getElementById('models').classList.contains('active')) {
        // Remove old canvas and re-init
        const container = document.getElementById('canvas-container');
        if (container) {
            while (container.firstChild) container.removeChild(container.firstChild);
        }
        init3D();
        // ensure renderer fits after re-init
        setTimeout(handleResize, 120);
    }
};

// --- Applications Data (30 Items) ---
const appData = [
    {
        id: "soda", icon: "fa-wine-bottle",
        title: { hy: "1. ‘∏’¥’∫’•’¨’´÷Ñ’´ ’è’°÷Ä’°", en: "1. Soda Can", ru: "1. –ë–∞–Ω–∫–∞" },
        desc: { hy: "’Ñ’°’Ø’•÷Ä’•’Ω’´ ’¥’´’∂’´’¥’°’¨’°÷Å’∏÷Ç’¥", en: "Surface minimization", ru: "–ú–∏–Ω–∏–º–∏–∑–∞—Ü–∏—è –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏" },
        content: {
            hy: `< p > <strong>‘Ω’∂’§’´÷Ä.</strong> ’è÷Ä’æ’°’Æ $V$ ’Æ’°’æ’°’¨’´ ’§’•’∫÷Ñ’∏÷Ç’¥ ’£’ø’∂’•’¨ ’£’¨’°’∂’´ ’°’µ’∂’∫’´’Ω’´ ’π’°÷É’Ω’•÷Ä, ’∏÷Ä’∏’∂÷Å ’§’•’∫÷Ñ’∏÷Ç’¥ ’¨÷Ä’´’æ ’¥’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’´ ’¥’°’Ø’•÷Ä’•’Ω’®(’∞’•’ø÷á’°’¢’°÷Ä’ù ’∂’µ’∏÷Ç’©’´ ’Æ’°’≠’Ω’®) ’Ø’¨’´’∂’´ ’∂’æ’°’¶’°’£’∏÷Ç’µ’∂’®:</p >
            <p><strong>’Ñ’°’©’•’¥’°’ø’´’Ø’°’Ø’°’∂ ‘±÷Ä’ø’°’Æ’∏÷Ç’¥.</strong></p>
            <div class="formula-box">
                <p>1. ‘æ’°’æ’°’¨’´ ’¢’°’∂’°’±÷á’´÷Å ’°÷Ä’ø’°’∞’°’µ’ø’•’∂÷Ñ ’¢’°÷Ä’±÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’®. $$ V = \\pi R^2 H \\implies H = \\frac{V}{\\pi R^2} $$</p>
                <p>2. ’è’•’≤’°’§÷Ä’•’∂÷Ñ ’¥’°’Ø’•÷Ä’•’Ω’´ ’¢’°’∂’°’±÷á’´ ’¥’•’ª. $$ S(R) = 2\\pi R^2 + 2\\pi R H = 2\\pi R^2 + \\frac{2V}{R} $$</p>
                <p>3. ‘≥’ø’∂’•’∂÷Ñ ’°’Æ’°’∂÷Å’µ’°’¨’® ÷á ’∞’°’æ’°’Ω’°÷Ä’•÷Å’∂’•’∂÷Ñ ’¶÷Ä’∏’µ’´ (’ß÷Ñ’Ω’ø÷Ä’•’¥’∏÷Ç’¥’´ ’∫’°’µ’¥’°’∂). $$ S'(R) = 4\\pi R - \\frac{2V}{R^2} = 0 $$ $$ 4\\pi R = \\frac{2V}{R^2} \\implies 2\\pi R^3 = V $$</p>
                <p>4. ’è’•’≤’°’§÷Ä’•’∂÷Ñ $V$-’´ ’°÷Ä’™’•÷Ñ’®. $$ 2\\pi R^3 = \\pi R^2 H \\implies 2R = H $$</p>
            </div>
            <p><strong>‘µ’¶÷Ä’°’Ø’°÷Å’∏÷Ç’©’µ’∏÷Ç’∂.</strong> ’Ü’µ’∏÷Ç’©’´ ’∂’æ’°’¶’°’£’∏÷Ç’µ’∂ ’Æ’°’≠’Ω’´ ’∞’°’¥’°÷Ä ’£’¨’°’∂’´ ’ø÷Ä’°’¥’°’£’´’Æ’® ($2R$) ’∫’•’ø÷Ñ ’ß ’∞’°’æ’°’Ω’°÷Ä ’¨’´’∂’´ ’¢’°÷Ä’±÷Ä’∏÷Ç’©’µ’°’∂’® ($H$):</p>`,
            ru: `< p > <strong>–ó–∞–¥–∞—á–∞.</strong> –ü–æ–ª—É—á–∏—Ç—å –∑–∞–¥–∞–Ω–Ω—ã–π –æ–±—ä–µ–º —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º —Ä–∞—Å—Ö–æ–¥–æ–º –∞–ª—é–º–∏–Ω–∏—è.</p > <p><strong>–†–µ—à–µ–Ω–∏–µ.</strong> –î–ª—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ —Ü–∏–ª–∏–Ω–¥—Ä–∞ \\(H = 2R\\).</p>`,
            en: `< p > <strong>Problem.</strong> Minimize aluminum usage for a given volume.</p > <p><strong>Solution.</strong> For an optimal cylinder, \\(H = 2R\\).</p>`
        }
    },
    {
        id: "tank", icon: "fa-truck-moving",
        title: { hy: "2. ’ë’´’Ω’ø’•’º’∂", en: "2. Tanker", ru: "2. –¶–∏—Å—Ç–µ—Ä–Ω–∞" },
        desc: { hy: "’É’∂’∑’¥’°’∂ ’¢’°’∑’≠’∏÷Ç’¥", en: "Pressure distribution", ru: "–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –¥–∞–≤–ª–µ–Ω–∏—è" },
        content: {
            hy: `< p > <strong>’ñ’´’¶’´’Ø’° ÷á ‘µ÷Ä’Ø÷Ä’°’π’°÷É’∏÷Ç’©’µ’∏÷Ç’∂.</strong> ‘ª’∂’π’∏÷Ç’û ’•’∂ ÷Å’´’Ω’ø’•’º’∂’∂’•÷Ä’® ’£’¨’°’∂’°’±÷á, ’°’µ’¨ ’∏’π ’©’• ’∏÷Ç’≤’≤’°’∂’Ø’µ’∏÷Ç’∂’°’∂’´’Ω’ø:</p >
    <div class="formula-box">
        <p>1. <strong>’É’∂’∑’¥’°’∂ ‘≤’°’∑’≠’∏÷Ç’¥.</strong> ’Ä’•’≤’∏÷Ç’Ø’® ’Ø’°’¥ ’£’°’¶’® ’≥’∂’∑’∏÷Ç’¥ ’ß ’£’∏÷Ä’Æ’°’§÷Ä’∏÷Ç’¥ ’°’∂’∏’©’´ ’∫’°’ø’•÷Ä’´ ’æ÷Ä’° ’¢’∏’¨’∏÷Ä ’∏÷Ç’≤’≤’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä’∏’æ: ‘≥’¨’°’∂’°’±÷á ’¥’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’´ ’§’•’∫÷Ñ’∏÷Ç’¥ ’°’º’°’ª’°’∂’∏÷Ç’¥ ’ß ’°’µ’Ω’∫’•’Ω ’Ø’∏’π’æ’°’Æ ¬´÷Ö’≤’°’Ø’°’µ’´’∂ ’¨’°÷Ä’∏÷Ç’¥¬ª (Hoop Stress), ’∏÷Ä’® ’∞’°’æ’°’Ω’°÷Ä’°’π’°÷É ’ß ’¢’°’∑’≠’æ’∏÷Ç’¥:</p>
        <p>$$ \\sigma = \\frac{Pr}{t} $$</p>
        <p>’∏÷Ä’ø’•’≤ $P$-’∂ ’≥’∂’∑’∏÷Ç’¥’∂ ’ß, $r$-’®’ù ’∑’°’º’°’æ’´’≤’®, $t$-’∂’ù ’∫’°’ø’´ ’∞’°’Ω’ø’∏÷Ç’©’µ’∏÷Ç’∂’®:</p>
        <p>2. <strong>‘±’∂’Ø’µ’∏÷Ç’∂’∂’•÷Ä’´ ‘≤’°÷Å’°’Ø’°’µ’∏÷Ç’©’µ’∏÷Ç’∂.</strong> ’à÷Ç’≤’≤’°’∂’Ø’µ’∏÷Ç’∂ ’°’∂’∏’©’∂’•÷Ä’´ ’§’•’∫÷Ñ’∏÷Ç’¥ ’°’∂’Ø’µ’∏÷Ç’∂’∂’•÷Ä’∏÷Ç’¥ ’°’º’°’ª’°’∂’∏÷Ç’¥ ’•’∂ ’°’∞’º’•’¨’´ ’¨’°÷Ä’∏÷Ç’¥’∂’•÷Ä (stress concentration), ’´’∂’π’® ’Ø’∫’°’∞’°’∂’ª’•÷Ä ’∑’°’ø ’°’æ’•’¨’´ ’∞’°’Ω’ø ÷á ’Æ’°’∂÷Ä ’¥’•’ø’°’≤:</p>
        <p>3. <strong>‘æ’°’∂÷Ä’∏÷Ç’©’µ’°’∂ ‘ø’•’∂’ø÷Ä’∏’∂.</strong> ’Ä’°’≥’°’≠ ÷Ö’£’ø’°’£’∏÷Ä’Æ’æ’∏÷Ç’¥ ’•’∂ ’ß’¨’´’∫’Ω’°’±÷á ’∞’°’ø’∏÷Ç’µ’©’∏’æ ’£’¨’°’∂’∂’•÷Ä’ù ’Æ’°’∂÷Ä’∏÷Ç’©’µ’°’∂ ’Ø’•’∂’ø÷Ä’∏’∂’® ’´’ª’•÷Å’∂’•’¨’∏÷Ç ÷á ’¥’•÷Ñ’•’∂’°’µ’´ ’Ø’°’µ’∏÷Ç’∂’∏÷Ç’©’µ’∏÷Ç’∂’® ’¥’•’Æ’°÷Å’∂’•’¨’∏÷Ç ’∞’°’¥’°÷Ä:</p>
    </div>`,
            ru: `< p > <strong>–§–∏–∑–∏–∫–∞.</strong> –¶–∏–ª–∏–Ω–¥—Ä–∏—á–µ—Å–∫–∞—è —Ñ–æ—Ä–º–∞ —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ—Ç –¥–∞–≤–ª–µ–Ω–∏–µ –∂–∏–¥–∫–æ—Å—Ç–∏.</p > `,
            en: `< p > <strong>Physics.</strong> The cylindrical shape distributes fluid pressure evenly.</p > `
        }
    },
    {
        id: "pen", icon: "fa-pen-nib",
        title: { hy: "3. ‘≥’∂’§’´’Ø’°’æ’∏÷Ä ‘≥÷Ä’´’π", en: "3. Ballpoint Pen", ru: "3. –®–∞—Ä–∏–∫–æ–≤–∞—è –†—É—á–∫–∞" },
        desc: { hy: "’á÷É’∏÷Ç’¥ ÷á ’∫’ø’∏÷Ç’µ’ø", en: "Friction & Rotation", ru: "–¢—Ä–µ–Ω–∏–µ –∏ –í—Ä–∞—â–µ–Ω–∏–µ" },
        content: {
            hy: `< p > <strong>‘ª’∂’™’•’∂’•÷Ä’°’Ø’°’∂ ’Ä÷Ä’°’∑÷Ñ.</strong> ‘≥÷Ä’´’π’´ ’Æ’°’µ÷Ä’® ÷É’∏÷Ñ÷Ä’´’Ø ’£’∏÷Ç’∂’§ ’ß(’Ω’∏’æ’∏÷Ä’°’¢’°÷Ä ’æ’∏’¨÷Ü÷Ä’°’¥’´ ’Ø’°÷Ä’¢’´’§’´÷Å), ’∏÷Ä’® ’Ø’°’ø’°÷Ä’∏÷Ç’¥ ’ß ’•÷Ä’Ø’∏÷Ç ÷Ü’∏÷Ç’∂’Ø÷Å’´’°’ù ÷É’°’Ø’∏÷Ç’¥ ’ß ’©’°’∂’°÷Ñ’´ ’≥’°’∂’°’∫’°÷Ä’∞’®(’π’´ ’©’∏’≤’∂’∏÷Ç’¥ ’π’∏÷Ä’°’∂’°) ÷á ’∫’ø’ø’æ’•’¨’∏’æ ’ø’•’≤’°÷É’∏’≠’∏÷Ç’¥ ’ß ’°’µ’∂ ’©’≤’©’´ ’æ÷Ä’°:</p >
    <div class="formula-box">
        <p><strong>‘µ÷Ä’Ø÷Ä’°’π’°÷É’°’Ø’°’∂ ’Ä’°’ø’Ø’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä.</strong></p>
        <p>1. <strong>’Ä’°’Ω’ø’°’ø’∏÷Ç’∂ ‘º’°’µ’∂’∏÷Ç’©’µ’∏÷Ç’∂.</strong> ‘≥’∏÷Ç’∂’§’® ’¥’´’°’Ø ’¥’°÷Ä’¥’´’∂’∂ ’ß, ’∏÷Ä’´ ’∫÷Ä’∏’µ’•’Ø÷Å’´’°’∂ ÷Å’°’∂’Ø’°÷Å’°’Æ ’∏÷Ç’≤’≤’∏÷Ç’©’µ’°’¥’¢ ’∑÷Ä’ª’°’∂ ’ß: ’ç’° ’©’∏÷Ç’µ’¨ ’ß ’ø’°’¨’´’Ω ’∂÷Ä’°’∂ ’°’¶’°’ø ’∫’ø’ø’æ’•’¨ ’¢’∂’´’Ø’∏÷Ç’¥ (socket) ÷Å’°’∂’Ø’°÷Å’°’Æ ’∏÷Ç’≤’≤’∏÷Ç’©’µ’°’¥’¢:</p>
        <p>2. <strong>’Ñ’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’´ ’Ñ’°’Ø’•÷Ä’•’Ω.</strong> $$ S = 4\\pi R^2 $$ ‘≥’∂’§’´ ’¥’°’Ø’•÷Ä’•’Ω’® ’°’∫’°’∞’∏’æ’∏÷Ç’¥ ’ß ’©’°’∂’°÷Ñ’´ ’°’º’°’æ’•’¨’°’£’∏÷Ç’µ’∂ ’ø’•’≤’°÷É’∏’≠’∏÷Ç’¥ ’¥’´’∂’´’¥’°’¨ ’π’°÷É’Ω’•÷Ä’´ ’§’•’∫÷Ñ’∏÷Ç’¥:</p>
        <p>3. <strong>’ç’´’¥’•’ø÷Ä’´’°.</strong> ‘≥’∏÷Ç’∂’§’∂ ’∏÷Ç’∂’´ ’Ø’°’ø’°÷Ä’µ’°’¨ ’Ω’´’¥’•’ø÷Ä’´’° ($O(3)$ ’≠’∏÷Ç’¥’¢), ’´’∂’π’® ’∂’∑’°’∂’°’Ø’∏÷Ç’¥ ’ß, ’∏÷Ä ’£÷Ä’•’¨’∏÷Ç ’°’∂’Ø’µ’∏÷Ç’∂’® ’∂’∑’°’∂’°’Ø’∏÷Ç’©’µ’∏÷Ç’∂ ’π’∏÷Ç’∂’´:</p>
    </div>`,
            ru: `< p > <strong>–ú–µ—Ö–∞–Ω–∏–∑–º.</strong> –ú–∞–ª–µ–Ω—å–∫–∏–π —à–∞—Ä–∏–∫ –Ω–∞ –∫–æ–Ω—Ü–µ —Ä—É—á–∫–∏ –≤—Ä–∞—â–∞–µ—Ç—Å—è –æ—Ç —Ç—Ä–µ–Ω–∏—è —Å –±—É–º–∞–≥–æ–π, –ø–µ—Ä–µ–Ω–æ—Å—è —á–µ—Ä–Ω–∏–ª–∞.</p > `,
            en: `< p > <strong>Mechanism.</strong> The small sphere at the tip rotates due to friction, transferring ink to the paper.</p > `
        }
    },
    {
        id: "cup", icon: "fa-glass-whiskey",
        title: { hy: "4. ’â’°÷É’´’π ‘≤’°’™’°’Ø", en: "4. Measuring Cup", ru: "4. –ú–µ—Ä–Ω—ã–π –°—Ç–∞–∫–∞–Ω" },
        desc: { hy: "‘æ’°’æ’°’¨’´ ’£’Æ’°’µ’∂’∏÷Ç’©’µ’∏÷Ç’∂", en: "Volume Linearity", ru: "–õ–∏–Ω–µ–π–Ω–æ—Å—Ç—å –û–±—ä–µ–º–∞" },
        content: {
            hy: `<p><strong>’Ñ’°’©’•’¥’°’ø’´’Ø’°.</strong> ‘≥’¨’°’∂’´ ’Æ’°’æ’°’¨’® ’∏÷Ä’∏’∑’æ’∏÷Ç’¥ ’ß $V = \\pi R^2 H$ ’¢’°’∂’°’±÷á’∏’æ: ’î’°’∂’´ ’∏÷Ä ’¢’°’™’°’Ø’´ ’∞’´’¥÷Ñ’´ ’∑’°’º’°’æ’´’≤’® ($R$) ’∞’°’Ω’ø’°’ø’∏÷Ç’∂ ’ß, ’∞’´’¥÷Ñ’´ ’¥’°’Ø’•÷Ä’•’Ω’®’ù $S = \\pi R^2$, ’∂’∏÷Ç’µ’∂’∫’•’Ω ’∞’°’Ω’ø’°’ø’∏÷Ç’∂ ’ß ($k$):</p>
                 <p>’ç’ø’°÷Å’æ’∏÷Ç’¥ ’ß ’£’Æ’°’µ’´’∂ ’Ø’°’≠’æ’°’Æ’∏÷Ç’©’µ’∏÷Ç’∂’ù $$ V(H) = k \\cdot H $$</p>
                 <p>’ç’° ’∂’∑’°’∂’°’Ø’∏÷Ç’¥ ’ß, ’∏÷Ä ’∞’•’≤’∏÷Ç’Ø’´ ’¢’°÷Ä’±÷Ä’∏÷Ç’©’µ’°’∂ ’µ’∏÷Ç÷Ä’°÷Ñ’°’∂’π’µ’∏÷Ç÷Ä 1 ’Ω’¥ ÷É’∏÷É’∏’≠’∏÷Ç’©’µ’∏÷Ç’∂’® ’∞’°’¥’°’∫’°’ø’°’Ω’≠’°’∂’∏÷Ç’¥ ’ß ’Æ’°’æ’°’¨’´ ’∂’∏÷Ç’µ’∂ ÷Ñ’°’∂’°’Ø’´ ÷É’∏÷É’∏’≠’∏÷Ç’©’µ’°’∂’®, ’´’∂’π’® ’©’∏÷Ç’µ’¨ ’ß ’ø’°’¨’´’Ω ÷Ö’£’ø’°’£’∏÷Ä’Æ’•’¨ ’∞’°’æ’°’Ω’°÷Ä’°’π’°÷É ’Ω’°’∂’§’≤’°’Ø:</p>`,
            ru: `<p><strong>–ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞.</strong> –û–±—ä–µ–º —Ü–∏–ª–∏–Ω–¥—Ä–∞ $V = \\pi R^2 H$. –¢–∞–∫ –∫–∞–∫ —Ä–∞–¥–∏—É—Å $R$ –ø–æ—Å—Ç–æ—è–Ω–µ–Ω, –æ–±—ä–µ–º –ª–∏–Ω–µ–π–Ω–æ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –≤—ã—Å–æ—Ç—ã: $$ V \\sim H $$</p>
                 <p>–≠—Ç–æ —Å–≤–æ–π—Å—Ç–≤–æ (–ª–∏–Ω–µ–π–Ω–æ—Å—Ç—å) –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–∞–Ω–æ—Å–∏—Ç—å –¥–µ–ª–µ–Ω–∏—è —à–∫–∞–ª—ã –Ω–∞ —Ä–∞–≤–Ω–æ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ –¥—Ä—É–≥ –æ—Ç –¥—Ä—É–≥–∞, —á—Ç–æ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ –¥–ª—è –∫–æ–Ω–∏—á–µ—Å–∫–∏—Ö –∏–ª–∏ —Å—Ñ–µ—Ä–∏—á–µ—Å–∫–∏—Ö —Å–æ—Å—É–¥–æ–≤.</p>`,
            en: `<p><strong>Mathematics.</strong> The volume of a cylinder is $V = \\pi R^2 H$. Since the radius $R$ is constant, the volume is linearly proportional to the height: $$ V \\propto H $$</p>
                 <p>This linearity allows for a uniform scale on the measuring cup, where equal vertical increments represent equal volume increments.</p>`
        }
    },
    {
        id: "disposable", icon: "fa-coffee",
        title: { hy: "5. ’Ñ’•’Ø’°’∂’£’°’¥’µ’° ‘≤’°’™’°’Ø", en: "5. Disposable Cup", ru: "5. –û–¥–Ω–æ—Ä–∞–∑–æ–≤—ã–π –°—Ç–∞–∫–∞–Ω" },
        desc: { hy: "‘¥’°’Ω’°’æ’∏÷Ä’∏÷Ç’¥ (Stacking)", en: "Stacking", ru: "–°–∫–ª–∞–¥–∏—Ä–æ–≤–∞–Ω–∏–µ" },
        content: {
            hy: `<p><strong>‘µ÷Ä’Ø÷Ä’°’π’°÷É’∏÷Ç’©’µ’∏÷Ç’∂.</strong> ‘≤’°’™’°’Ø’® ’∞’°’ø’°’Æ ’Ø’∏’∂ ’ß ($r_1 < r_2$):</p>
                 <p><strong>‘¥’°’Ω’°’æ’∏÷Ä’∏÷Ç’¥ (Stacking).</strong> ‘µ÷Ä’¢ ’¥’´ ’¢’°’™’°’Ø’® ’§÷Ä’æ’∏÷Ç’¥ ’ß ’¥’µ’∏÷Ç’Ω’´ ’¥’•’ª, ’°’µ’∂ ’´’ª’∂’∏÷Ç’¥ ’ß ’¥’´’∂’π÷á ’Ø’∏’≤’¥’∂’°’µ’´’∂ ’∫’°’ø’•÷Ä’® ’∞’∫’æ’•’∂: ‘ª’§’•’°’¨’°’Ø’°’∂ ’£’¨’°’∂’∂’•÷Ä’´ ’§’•’∫÷Ñ’∏÷Ç’¥ ($r_1 = r_2$) ’§÷Ä’°’∂÷Ñ ’Ø’Ω’°’∞’•’´’∂ ’¥’´’∂’π÷á ’∞’°’ø’°’Ø ÷á ’Ø’°’º’°’ª’°÷Å’∂’•’´’∂ ’æ’°’Ø’∏÷Ç’∏÷Ç’¥, ’´’∂’π’® ’Ø’§’™’æ’°÷Ä’°÷Å’∂’•÷Ä ’¢’°’™’°’∂’•’¨’®:</p>
                 <p>’Ä’°’ø’°’Æ ’Ø’∏’∂’´ ’Æ’°’æ’°’¨’®’ù $$ V = \\frac{1}{3}\\pi h(R^2 + r^2 + Rr) $$</p>`,
            ru: `<p><strong>–ì–µ–æ–º–µ—Ç—Ä–∏—è.</strong> –§–æ—Ä–º–∞ —É—Å–µ—á–µ–Ω–Ω–æ–≥–æ –∫–æ–Ω—É—Å–∞ –ø–æ–∑–≤–æ–ª—è–µ—Ç –≤–∫–ª–∞–¥—ã–≤–∞—Ç—å —Å—Ç–∞–∫–∞–Ω—ã –¥—Ä—É–≥ –≤ –¥—Ä—É–≥–∞ (—à—Ç–∞–±–µ–ª–∏—Ä–æ–≤–∞–Ω–∏–µ).</p>
                 <p>–í –æ—Ç–ª–∏—á–∏–µ –æ—Ç —Ü–∏–ª–∏–Ω–¥—Ä–æ–≤, –∫–æ–Ω–∏—á–µ—Å–∫–∏–µ —Å—Ç–µ–Ω–∫–∏ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞—é—Ç –∑–∞–∫–ª–∏–Ω–∏–≤–∞–Ω–∏–µ –∏ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤–∞–∫—É—É–º–∞ –º–µ–∂–¥—É —Å—Ç–∞–∫–∞–Ω–∞–º–∏. –û–±—ä–µ–º —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è –ø–æ —Ñ–æ—Ä–º—É–ª–µ: $$ V = \\frac{1}{3}\\pi h(R^2 + r^2 + Rr) $$</p>`,
            en: `<p><strong>Geometry.</strong> The frustum shape allows for efficient stacking (nesting).</p>
                 <p>Unlike perfect cylinders, the tapered walls prevent vacuum lock and allow cups to stop at a precise height when stacked. Volume formula: $$ V = \\frac{1}{3}\\pi h(R^2 + r^2 + Rr) $$</p>`
        }
    },
    {
        id: "coins", icon: "fa-coins",
        title: { hy: "6. ’Ñ’°’∂÷Ä’°’§÷Ä’°’¥’∂’•÷Ä", en: "6. Coins", ru: "6. –ú–æ–Ω–µ—Ç—ã" },
        desc: { hy: "‘≥’¨’°’∂’°’µ’´’∂ ’Ω’ø’∏÷Ç’£’∏÷Ç’¥", en: "Cylindrical Testing", ru: "–ü—Ä–æ–≤–µ—Ä–∫–∞ –¶–∏–ª–∏–Ω–¥—Ä–∞" },
        content: {
            hy: `<p><strong>‘≥’¨’°’∂’°’µ’´’∂ ’ä’°÷Ä’°’¥’•’ø÷Ä’•÷Ä.</strong> ‘±’æ’ø’∏’¥’°’ø’∂’•÷Ä’® ’ø’°÷Ä’¢’•÷Ä’°’Ø’∏÷Ç’¥ ’•’∂ ’¥’•’ø’°’≤’°’§÷Ä’°’¥’∂’•÷Ä’®’ù ’π’°÷É’•’¨’∏’æ ’§÷Ä’°’∂÷Å ÷Ü’´’¶’´’Ø’°’Ø’°’∂ ’∫’°÷Ä’°’¥’•’ø÷Ä’•÷Ä’®, ’∏÷Ä’∏’∂÷Ñ ’¢’∂’∏÷Ç’©’°’£÷Ä’∏÷Ç’¥ ’•’∂ ’£’¨’°’∂’®:</p>
                 <ul>
                    <li><strong>’è÷Ä’°’¥’°’£’´’Æ ($2R$):</strong> ’â’°÷É’æ’∏÷Ç’¥ ’ß ÷Ö’∫’ø’´’Ø’°’Ø’°’∂ ’Ω’•’∂’Ω’∏÷Ä’∂’•÷Ä’∏’æ:</li>
                    <li><strong>’Ä’°’Ω’ø’∏÷Ç’©’µ’∏÷Ç’∂ ($H$):</strong> ’â’°÷É’æ’∏÷Ç’¥ ’ß ’°’∂÷Å÷Ñ’´ ’π’°÷É’Ω’∏’æ:</li>
                    <li><strong>‘∂’°’∂’£’æ’°’Æ ($m$):</strong> $m = \\rho V = \\rho \\cdot (\\pi R^2 H)$, ’∏÷Ä’ø’•’≤ $\\rho$-’∂ ’¥’•’ø’°’≤’´ ’≠’ø’∏÷Ç’©’µ’∏÷Ç’∂’∂ ’ß:</li>
                 </ul>`,
            ru: `<p><strong>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¶–∏–ª–∏–Ω–¥—Ä–∞.</strong> –¢–æ—Ä–≥–æ–≤—ã–µ –∞–≤—Ç–æ–º–∞—Ç—ã –ø—Ä–æ–≤–µ—Ä—è—é—Ç –ø–æ–¥–ª–∏–Ω–Ω–æ—Å—Ç—å –º–æ–Ω–µ—Ç, –∏–∑–º–µ—Ä—è—è:</p>
                 <ul>
                    <li><strong>–î–∏–∞–º–µ—Ç—Ä ($2R$) –∏ –¢–æ–ª—â–∏–Ω—É ($H$):</strong> –ì–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–µ —Ä–∞–∑–º–µ—Ä—ã.</li>
                    <li><strong>–ú–∞—Å—Å—É ($m$):</strong> –ó–∞–≤–∏—Å–∏—Ç –æ—Ç –æ–±—ä–µ–º–∞ —Ü–∏–ª–∏–Ω–¥—Ä–∞ –∏ –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏ —Å–ø–ª–∞–≤–∞: $$ m = \\rho \\cdot \\pi R^2 H $$</li>
                 </ul>`,
            en: `<p><strong>Cylindrical Parameters.</strong> Vending machines validate coins by measuring:</p>
                 <ul>
                    <li><strong>Diameter ($2R$) & Thickness ($H$):</strong> Geometric constraints.</li>
                    <li><strong>Mass ($m$):</strong> Calculated from volume and density: $$ m = \\rho \\cdot \\pi R^2 H $$</li>
                 </ul>`
        }
    },
    {
        id: "lamp", icon: "fa-lightbulb",
        title: { hy: "7. ’ì’∏’≤’∏÷Å’°’µ’´’∂ ‘º’°’¥’∫", en: "7. Street Lamp", ru: "7. –£–ª–∏—á–Ω—ã–π –§–æ–Ω–∞—Ä—å" },
        desc: { hy: "‘º’∏÷Ç’µ’Ω’´ ÷Å÷Ä’∏÷Ç’¥", en: "Light Dispersion", ru: "–†–∞—Å—Å–µ–∏–≤–∞–Ω–∏–µ –°–≤–µ—Ç–∞" },
        content: {
            hy: `<p><strong>‘≥’¨’°’∂’°’µ’´’∂ ’à’Ω’∫’∂’µ’°’Ø.</strong> ‘º’°’¥’∫’´ ’°’∫’°’Ø’´’∂ ’∞’°’≥’°’≠ ’∏÷Ç’∂’•’∂’∏÷Ç’¥ ’ß ’∏÷Ç’≤’≤’°’∞’°’µ’°÷Å ’∫÷Ä’´’¶’¥’°’∂’•÷Ä ’Ø’°’¥ ’£’¨’°’∂’°’µ’´’∂ ’¥’°’Ø’•÷Ä÷á’∏÷Ç’µ’©:</p>
                 <p>’ç’° ’©’∏÷Ç’µ’¨ ’ß ’ø’°’¨’´’Ω ’¨’∏÷Ç’µ’Ω’® ÷Å÷Ä’•’¨ ’∞’∏÷Ä’´’¶’∏’∂’°’Ø’°’∂ ’∏÷Ç’≤’≤’∏÷Ç’©’µ’°’¥’¢ (’≥’°’∂’°’∫’°÷Ä’∞’´ ’•÷Ä’Ø’°’µ’∂÷Ñ’∏’æ)’ù ’π’Ø’∏÷Ä÷Å’∂’•’¨’∏’æ ’°’µ’∂ ’§’•’∫’´ ’æ’•÷Ä ’Ø’°’¥ ’∂’•÷Ä÷Ñ÷á: ‘±÷Ä’§’µ’∏÷Ç’∂÷Ñ’∏÷Ç’¥ ’Ω’ø’°÷Å’æ’∏÷Ç’¥ ’ß ’ß’¨’´’∫’Ω’°’±÷á ’¨’∏÷Ç’Ω’°’æ’∏÷Ä’æ’°’Æ ’£’∏’ø’´:</p>`,
            ru: `<p><strong>–¶–∏–ª–∏–Ω–¥—Ä–∏—á–µ—Å–∫–∞—è –õ–∏–Ω–∑–∞.</strong> –°—Ç–µ–∫–ª–æ —Ñ–æ–Ω–∞—Ä—è —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–∞–∫ –ª–∏–Ω–∑–∞, —Ä–∞—Å—Å–µ–∏–≤–∞—è —Å–≤–µ—Ç –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–µ–Ω–Ω–æ –≤ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–π –ø–ª–æ—Å–∫–æ—Å—Ç–∏.</p>
                 <p>–≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –æ—Å–≤–µ—â–∞—Ç—å –¥–ª–∏–Ω–Ω—ã–π —É—á–∞—Å—Ç–æ–∫ –¥–æ—Ä–æ–≥–∏, –∞ –Ω–µ –ø—Ä–æ—Å—Ç–æ –∫—Ä—É–≥ –ø–æ–¥ —Å—Ç–æ–ª–±–æ–º.</p>`,
            en: `<p><strong>Cylindrical Lens.</strong> The glass cover acts as a cylindrical lens, dispersing light horizontally along the road path.</p>
                 <p>This creates an elliptical illumination pattern, maximizing efficiency for street lighting.</p>`
        }
    },
    {
        id: "nose", icon: "fa-plane",
        title: { hy: "8. ‘ª’∂÷Ñ’∂’°’©’´’º’´ ’î’´’©", en: "8. Airplane Nose", ru: "8. –ù–æ—Å –°–∞–º–æ–ª–µ—Ç–∞" },
        desc: { hy: "‘±’•÷Ä’∏’§’´’∂’°’¥’´’Ø’°", en: "Aerodynamics", ru: "–ê—ç—Ä–æ–¥–∏–Ω–∞–º–∏–∫–∞" },
        content: {
            hy: `<p><strong>’ä’ø’ø’°’Ø’°’∂ ’ä’°÷Ä’°’¢’∏’¨’∏’´’§.</strong> ‘ª’∂÷Ñ’∂’°’©’´’º’´ ÷Ñ’´’©’® ’∞’°’≥’°’≠ ’∏÷Ç’∂’´ ’∫’°÷Ä’°’¢’∏’¨’∏’´’§’´ ’Ø’°’¥ ’ß’¨’´’∫’Ω’∏’´’§’´ ’ø’•’Ω÷Ñ ($z = ax^2 + by^2$):</p>
                 <p>‘±’µ’Ω ’±÷á’® ’°’∫’°’∞’∏’æ’∏÷Ç’¥ ’ß ÷Ö’§’´ ’∞’∏’Ω÷Ñ’´ ’Ω’°’∞’∏÷Ç’∂ ’∑÷Ä’ª’°’∂÷Å’∏÷Ç’¥ (’¨’°’¥’´’∂’°÷Ä ’∞’∏’Ω÷Ñ)’ù ’∂’æ’°’¶’°’£’∏÷Ç’µ’∂’´ ’∞’°’Ω÷Å’∂’•’¨’∏’æ ’≥’°’Ø’°’ø’°’µ’´’∂ ’§’´’¥’°’§÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’® ($Drag$):</p>`,
            ru: `<p><strong>–ü–∞—Ä–∞–±–æ–ª–æ–∏–¥ –í—Ä–∞—â–µ–Ω–∏—è.</strong> –§–æ—Ä–º–∞ –Ω–æ—Å–∞ –æ–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è —É—Ä–∞–≤–Ω–µ–Ω–∏–µ–º $$ z = c(x^2 + y^2) $$</p>
                 <p>–¢–∞–∫–∞—è –≥–µ–æ–º–µ—Ç—Ä–∏—è –º–∏–Ω–∏–º–∏–∑–∏—Ä—É–µ—Ç –∞—ç—Ä–æ–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ –Ω–∞ –¥–æ–∑–≤—É–∫–æ–≤—ã—Ö –∏ —Å–≤–µ—Ä—Ö–∑–≤—É–∫–æ–≤—ã—Ö —Å–∫–æ—Ä–æ—Å—Ç—è—Ö.</p>`,
            en: `<p><strong>Paraboloid of Revolution.</strong> The nose shape often follows a parabolic curve $$ z = c(x^2 + y^2) $$</p>
                 <p>This geometry ensures laminar airflow and minimizes aerodynamic drag coefficient ($C_d$).</p>`
        }
    },
    {
        id: "lens", icon: "fa-eye",
        title: { hy: "9. ’à’Ω’∫’∂’µ’°’Ø", en: "9. Lens", ru: "9. –õ–∏–Ω–∑–∞" },
        desc: { hy: "’ï’∫’ø’´’Ø’°", en: "Optics", ru: "–û–ø—Ç–∏–∫–∞" },
        content: {
            hy: `<p><strong>‘≥’∂’§’°’µ’´’∂ ’ç’•’£’¥’•’∂’ø’∂’•÷Ä.</strong> ’à’Ω’∫’∂’µ’°’Ø’® ’•÷Ä’Ø÷Ä’°’π’°÷É’∏÷Ä’•’∂ ’•÷Ä’Ø’∏÷Ç ’£’∂’§’°’µ’´’∂ ’Ω’•’£’¥’•’∂’ø’∂’•÷Ä’´ ’∞’°’ø’∏÷Ç’¥ ’ß (’∏÷Ç’º’∏÷Ç÷Å’´’Ø ’∏’Ω’∫’∂’µ’°’Ø):</p>
                 <p>’à’Ω’∫’∂’µ’°’Ø’´ ÷Ö’∫’ø’´’Ø’°’Ø’°’∂ ’∏÷Ç’™’® ($D$) ’Ø’°’≠’æ’°’Æ ’ß ’°’µ’§ ’Ω’•’£’¥’•’∂’ø’∂’•÷Ä’´ ’∑’°’º’°’æ’´’≤’∂’•÷Ä’´÷Å ($R_1, R_2$): $$ D = (n-1)(\\frac{1}{R_1} + \\frac{1}{R_2}) $$</p>`,
            ru: `<p><strong>–°—Ñ–µ—Ä–∏—á–µ—Å–∫–∏–µ –°–µ–≥–º–µ–Ω—Ç—ã.</strong> –õ–∏–Ω–∑–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –¥–≤—É—Ö —à–∞—Ä–æ–≤—ã—Ö —Å–µ–≥–º–µ–Ω—Ç–æ–≤.</p>
                 <p>–§–æ—Ä–º—É–ª–∞ —à–ª–∏—Ñ–æ–≤—â–∏–∫–∞ –ª–∏–Ω–∑ —Å–≤—è–∑—ã–≤–∞–µ—Ç —Ä–∞–¥–∏—É—Å—ã –∫—Ä–∏–≤–∏–∑–Ω—ã ($R_1, R_2$) —Å —Ñ–æ–∫—É—Å–Ω—ã–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ–º: $$ \\frac{1}{f} = (n-1)(\\frac{1}{R_1} + \\frac{1}{R_2}) $$</p>`,
            en: `<p><strong>Spherical Segments.</strong> A convex lens is geometrically the intersection of two spherical segments.</p>
                 <p>The Lens Maker's Equation relates the radii of curvature ($R_1, R_2$) to the focal length ($f$): $$ \\frac{1}{f} = (n-1)(\\frac{1}{R_1} + \\frac{1}{R_2}) $$</p>`
        }
    },
    {
        id: "silo", icon: "fa-warehouse",
        title: { hy: "10. ’ç’´’¨’∏’Ω’°’µ’´’∂ ’Ä’∏÷Ä", en: "10. Silo", ru: "10. –°–∏–ª–æ—Å" },
        desc: { hy: "’ä’°’∞’•’Ω’ø’°’æ’∏÷Ä’∏÷Ç’¥", en: "Storage", ru: "–•—Ä–∞–Ω–µ–Ω–∏–µ" },
        content: {
            hy: `<p><strong>‘≤’°’≤’°’§÷Ä’µ’°’¨ ’Ñ’°÷Ä’¥’´’∂.</strong> ’ç’´’¨’∏’Ω’® ’Ø’°’¶’¥’æ’°’Æ ’ß ’£’¨’°’∂’´÷Å (’∞’´’¥’∂’°’Ø’°’∂ ’Æ’°’æ’°’¨) ÷á ’Ø’∏’∂’´÷Å (’∞’°’ø’°’Ø):</p>
                 <p><strong>‘∏’∂’§’∞’°’∂’∏÷Ç÷Ä ‘æ’°’æ’°’¨.</strong> $$ V_{total} = V_{cyl} + V_{cone} = \\pi R^2 H_{cyl} + \\frac{1}{3}\\pi R^2 H_{cone} $$</p>
                 <p>‘ø’∏’∂’°’±÷á ’∞’°’ø’°’Ø’® ’°’∫’°’∞’∏’æ’∏÷Ç’¥ ’ß ’∞’°÷Å’°’∞’°’ø’´’Ø’´ ’´’∂÷Ñ’∂’°’∞’∏’Ω ’¢’•’º’∂’°’©’°÷É’∏÷Ç’¥’® ’£÷Ä’°’æ’´’ø’°÷Å’´’°’µ’´ ’∏÷Ç’™’∏’æ:</p>`,
            ru: `<p><strong>–°–æ—Å—Ç–∞–≤–Ω–æ–µ –¢–µ–ª–æ.</strong> –°–∏–ª–æ—Å —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ —Ü–∏–ª–∏–Ω–¥—Ä–∞ (—Ö—Ä–∞–Ω–µ–Ω–∏–µ) –∏ –∫–æ–Ω—É—Å–∞ (–≤—ã–≥—Ä—É–∑–∫–∞).</p>
                 <p><strong>–û–±—â–∏–π –û–±—ä–µ–º:</strong> $$ V = \\pi R^2 H_1 + \\frac{1}{3}\\pi R^2 H_2 $$</p>
                 <p>–£–≥–æ–ª –∫–æ–Ω—É—Å–∞ —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è —Ç–∞–∫, —á—Ç–æ–±—ã –ø—Ä–µ–≤—ã—à–∞—Ç—å —É–≥–æ–ª —Ç—Ä–µ–Ω–∏—è –∑–µ—Ä–Ω–∞ –¥–ª—è —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞.</p>`,
            en: `<p><strong>Composite Solid.</strong> A silo combines a cylinder for maximum storage volume with a cone for discharge.</p>
                 <p><strong>Total Volume:</strong> $$ V = \\pi R^2 H_{cyl} + \\frac{1}{3}\\pi R^2 H_{cone} $$</p>
                 <p>The cone angle is designed to ensure mass flow of the granular material.</p>`
        }
    },
    {
        id: "bearing", icon: "fa-ring",
        title: { hy: "11. ‘±’º’°’∂÷Å÷Ñ’°’Ø’°’¨", en: "11. Ball Bearing", ru: "11. –ü–æ–¥—à–∏–ø–Ω–∏–∫" },
        desc: { hy: "’á÷É’¥’°’∂ ’∂’æ’°’¶’•÷Å’∏÷Ç’¥", en: "Friction Reduction", ru: "–°–Ω–∏–∂–µ–Ω–∏–µ –¢—Ä–µ–Ω–∏—è" },
        content: {
            hy: `<p><strong>‘ø’•’ø’°’µ’´’∂ ’Ä’∫’∏÷Ç’¥.</strong> ‘ª’§’•’°’¨’°’Ø’°’∂ ’£’∏÷Ç’∂’§’® ’∞’°÷Ä’©’∏÷Ç’©’µ’°’∂’® ’∞’∫’æ’∏÷Ç’¥ ’ß ’¥’´’°’µ’∂ ’¥’•’Ø ’Ø’•’ø’∏÷Ç’¥:</p>
                 <p>’ç’° ’∂’∑’°’∂’°’Ø’∏÷Ç’¥ ’ß, ’∏÷Ä ’∑÷É’¥’°’∂ ’¥’°’Ø’•÷Ä’•’Ω’® ’±’£’ø’∏÷Ç’¥ ’ß ’¶÷Ä’∏’µ’´, ’´’∂’π’® ’Ø’ø÷Ä’∏÷Ç’Ø ’∂’æ’°’¶’•÷Å’∂’∏÷Ç’¥ ’ß ’§’´’¥’°’§÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’®: ’ç’°’∞÷Ñ’´ ’∑÷É’∏÷Ç’¥’® ÷É’∏’≠’°÷Ä’´’∂’æ’∏÷Ç’¥ ’ß ’£’¨’∏÷Ä’¥’°’∂ ’∑÷É’∏÷Ç’¥’∏’æ ($F_{roll} \\ll F_{slide}$):</p>`,
            ru: `<p><strong>–¢–æ—á–µ—á–Ω—ã–π –ö–æ–Ω—Ç–∞–∫—Ç.</strong> –°—Ñ–µ—Ä–∞ –∫–∞—Å–∞–µ—Ç—Å—è –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ –≤ –æ–¥–Ω–æ–π —Ç–æ—á–∫–µ (—Ç–µ–æ—Ä–µ—Ç–∏—á–µ—Å–∫–∏).</p>
                 <p>–≠—Ç–æ –º–∏–Ω–∏–º–∏–∑–∏—Ä—É–µ—Ç –ø–ª–æ—â–∞–¥—å –∫–æ–Ω—Ç–∞–∫—Ç–∞ –∏ –∑–∞–º–µ–Ω—è–µ—Ç —Ç—Ä–µ–Ω–∏–µ —Å–∫–æ–ª—å–∂–µ–Ω–∏—è –Ω–∞ —Ç—Ä–µ–Ω–∏–µ –∫–∞—á–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä–æ–µ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –º–µ–Ω—å—à–µ.</p>`,
            en: `<p><strong>Point Contact.</strong> A perfect sphere contacts a plane at a single point.</p>
                 <p>This minimizes contact area and substitutes sliding friction with rolling friction ($F_{roll} \\ll F_{slide}$), enabling smooth rotation.</p>`
        }
    },
    {
        id: "cooling", icon: "fa-industry",
        title: { hy: "12. ’Ä’∏’æ’°÷Å’¥’°’∂ ‘±’∑’ø’°÷Ä’°’Ø", en: "12. Cooling Tower", ru: "12. –ì—Ä–∞–¥–∏—Ä–Ω—è" },
        desc: { hy: "’Ä’´’∫’•÷Ä’¢’∏’¨’∏’´’§", en: "Hyperboloid", ru: "–ì–∏–ø–µ—Ä–±–æ–ª–æ–∏–¥" },
        content: {
            hy: `<p><strong>’Ñ’´’°’≠’∏’º’∏’π ’Ä’´’∫’•÷Ä’¢’∏’¨’∏’´’§.</strong> ’Ü’Ø’°÷Ä’°’£÷Ä’æ’∏÷Ç’¥ ’ß ’∞’•’ø÷á’µ’°’¨ ’∞’°’æ’°’Ω’°÷Ä’¥’°’¥’¢’ù $$ \\frac{x^2+y^2}{a^2} - \\frac{z^2}{c^2} = 1 $$</p>
                 <p>‘±’µ’Ω ’±÷á’® ’Ω’ø’°÷Å’æ’∏÷Ç’¥ ’ß ’∏÷Ç’≤’´’≤ ’£’Æ’•÷Ä’´ (’°÷Ä’¥’°’ø’∏÷Ç÷Ä’°’∂’•÷Ä’´) ’∫’ø’∏÷Ç’µ’ø’∏’æ, ’´’∂’π’® ’∞’•’∑’ø’°÷Å’∂’∏÷Ç’¥ ’ß ’Ø’°’º’∏÷Ç÷Å’∏÷Ç’¥’®: ’Ü’•’≤’°÷Å’∏’≤ ’æ’¶’´’Ø’® ’°÷Ä’°’£’°÷Å’∂’∏÷Ç’¥ ’ß ÷Ö’§’´ ’∞’∏’Ω÷Ñ’® (’é’•’∂’ø’∏÷Ç÷Ä’´’´ ’ß÷Ü’•’Ø’ø):</p>`,
            ru: `<p><strong>–û–¥–Ω–æ–ø–æ–ª–æ—Å—Ç–Ω—ã–π –ì–∏–ø–µ—Ä–±–æ–ª–æ–∏–¥.</strong> –£—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏: $$ \\frac{x^2+y^2}{a^2} - \\frac{z^2}{c^2} = 1 $$</p>
                 <p>–õ–∏–Ω–µ–π—á–∞—Ç–∞—è –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å: –±–∞—à–Ω—é –º–æ–∂–Ω–æ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –∏–∑ –ø—Ä—è–º—ã—Ö –±–∞–ª–æ–∫. –°—É–∂–µ–Ω–∏–µ —Å–æ–∑–¥–∞–µ—Ç —Ç—è–≥—É –¥–ª—è –æ—Ö–ª–∞–∂–¥–µ–Ω–∏—è.</p>`,
            en: `<p><strong>One-sheeted Hyperboloid.</strong> Described by the equation: $$ \\frac{x^2+y^2}{a^2} - \\frac{z^2}{c^2} = 1 $$</p>
                 <p>It is a ruled surface, meaning it can be constructed with straight beams. The narrowing neck accelerates updraft (Venturi effect).</p>`
        }
    },
    {
        id: "dish", icon: "fa-satellite-dish",
        title: { hy: "13. ‘±÷Ä’¢’°’∂’µ’°’Ø’°’µ’´’∂ ‘±’¨’•’∞’°’æ’°÷Ñ", en: "13. Satellite Dish", ru: "13. –°–ø—É—Ç–Ω–∏–∫–æ–≤–∞—è –¢–∞—Ä–µ–ª–∫–∞" },
        desc: { hy: "‘±’¶’§’°’∂’∑’°’∂’´ ’Ø’•’∂’ø÷Ä’∏’∂’°÷Å’∏÷Ç’¥", en: "Signal Focusing", ru: "–§–æ–∫—É—Å–∏—Ä–æ–≤–∫–∞ –°–∏–≥–Ω–∞–ª–∞" },
        content: {
            hy: `<p><strong>’ä’°÷Ä’°’¢’∏’¨’∏’´’§’´ ’ï’∫’ø’´’Ø’°’Ø’°’∂ ’Ä’°’ø’Ø’∏÷Ç’©’µ’∏÷Ç’∂’®.</strong> ’ä’°÷Ä’°’¢’∏’¨’∏’´’§’´ ’°’º’°’∂÷Å÷Ñ’´’∂ ’¶’∏÷Ç’£’°’∞’•’º ’®’∂’Ø’∂’∏’≤ ’¢’∏’¨’∏÷Ä ’≥’°’º’°’£’°’µ’©’∂’•÷Ä’® ’°’∂’§÷Ä’°’§’°’º’∂’°’¨’∏÷Ç÷Å ’∞’•’ø’∏ ’°’∂÷Å’∂’∏÷Ç’¥ ’•’∂ ’¥’´÷á’∂’∏÷Ç’µ’∂ ’Ø’•’ø’∏’æ’ù ÷Ü’∏’Ø’∏÷Ç’Ω’∏’æ ($F$):</p>
                 <p>’ñ’∏’Ø’∏÷Ç’Ω’°’µ’´’∂ ’∞’•’º’°’æ’∏÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’®’ù $$ f = \\frac{R^2}{4h} $$</p>`,
            ru: `<p><strong>–°–≤–æ–π—Å—Ç–≤–æ –ü–∞—Ä–∞–±–æ–ª–æ–∏–¥–∞.</strong> –í—Å–µ –ª—É—á–∏, –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–µ –æ—Å–∏, —Å–æ–±–∏—Ä–∞—é—Ç—Å—è –≤ —Ñ–æ–∫—É—Å–µ.</p>
                 <p>–≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç —É—Å–∏–ª–∏–≤–∞—Ç—å —Å–ª–∞–±—ã–π —Å–ø—É—Ç–Ω–∏–∫–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª –≤ —Ç—ã—Å—è—á–∏ —Ä–∞–∑, –∫–æ–Ω—Ü–µ–Ω—Ç—Ä–∏—Ä—É—è –µ–≥–æ –Ω–∞ –ø—Ä–∏–µ–º–Ω–∏–∫–µ.</p>`,
            en: `<p><strong>Parabolic Reflection.</strong> All incoming rays parallel to the axis of symmetry are reflected to a single focal point ($F$).</p>
                 <p>Focal length formula: $$ f = \\frac{D^2}{16d} $$ where $D$ is diameter and $d$ is depth.</p>`
        }
    },
    {
        id: "piston", icon: "fa-car",
        title: { hy: "14. ’Ñ’≠’∏÷Å (’á’°÷Ä’™’´’π)", en: "14. Piston", ru: "14. –ü–æ—Ä—à–µ–Ω—å" },
        desc: { hy: "’Ä’•÷Ä’¥’•’ø’´’Ø’∏÷Ç’©’µ’∏÷Ç’∂", en: "Sealing", ru: "–ì–µ—Ä–º–µ—Ç–∏—á–Ω–æ—Å—Ç—å" },
        content: {
            hy: `<p><strong>‘ª’§’•’°’¨’°’Ø’°’∂ ‘≥’¨’°’∂.</strong> ’Ñ’≠’∏÷Å’´ ÷á ’£’¨’°’∂’´ ’°÷Ä’°’∂÷Ñ’® (’¢’°÷Å’°’Ø’®) ’∫’•’ø÷Ñ ’ß ’¨’´’∂’´ ’¥’´’Ø÷Ä’∏’¥’•’ø÷Ä’•÷Ä’´ ’Ø’°÷Ä’£’´:</p>
                 <p>‘≥’¨’°’∂’°’±÷á ’¥’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’® ’©’∏÷Ç’µ’¨ ’ß ’ø’°’¨’´’Ω ÷Ö’£’ø’°’£’∏÷Ä’Æ’•’¨ ÷Ö’≤’°’Ø’∂’•÷Ä (piston rings), ’∏÷Ä’∏’∂÷Ñ ’∞’°’æ’°’Ω’°÷Ä’°’π’°÷É ’≥’∂’∑’∏÷Ç’¥ ’•’∂ ’£’∏÷Ä’Æ’°’§÷Ä’∏÷Ç’¥ ’∫’°’ø’•÷Ä’´’∂’ù ’°’∫’°’∞’∏’æ’•’¨’∏’æ ’Ø’∏’¥’∫÷Ä’•’Ω’´’°:</p>`,
            ru: `<p><strong>–ì–µ—Ä–º–µ—Ç–∏—á–Ω–æ—Å—Ç—å.</strong> –¶–∏–ª–∏–Ω–¥—Ä–∏—á–µ—Å–∫–∞—è —Ñ–æ—Ä–º–∞ –ø–æ–∑–≤–æ–ª—è–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–æ–º–ø—Ä–µ—Å—Å–∏–æ–Ω–Ω—ã–µ –∫–æ–ª—å—Ü–∞.</p>
                 <p>–û–Ω–∏ —Å–æ–∑–¥–∞—é—Ç —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ–µ –¥–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ —Å—Ç–µ–Ω–∫–∏ ($P = const$) –ø–æ –≤—Å–µ–π –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–∏, –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞—è –ø—Ä–æ—Ä—ã–≤ –≥–∞–∑–æ–≤.</p>`,
            en: `<p><strong>Sealing.</strong> The cylindrical geometry allows for the use of piston rings which exert uniform radial pressure.</p>
                 <p>This ensures a perfect seal essential for the thermodynamic cycle of the engine.</p>`
        }
    },
    {
        id: "fiber", icon: "fa-network-wired",
        title: { hy: "15. ’ï’∫’ø’´’Ø’°’Ø’°’∂ ’Ñ’°’∂÷Ä’°’©’•’¨", en: "15. Optical Fiber", ru: "15. –û–ø—Ç–æ–≤–æ–ª–æ–∫–Ω–æ" },
        desc: { hy: "‘º÷Ä’´’æ ’°’∂’§÷Ä’°’§’°÷Ä’±’∏÷Ç’¥", en: "Total Reflection", ru: "–ü–æ–ª–Ω–æ–µ –û—Ç—Ä–∞–∂–µ–Ω–∏–µ" },
        content: {
            hy: `<p><strong>‘º÷Ä’´’æ ’Ü’•÷Ä÷Ñ’´’∂ ‘±’∂’§÷Ä’°’§’°÷Ä’±’∏÷Ç’¥.</strong> ‘º’∏÷Ç’µ’Ω’® ’ø’°÷Ä’°’Æ’æ’∏÷Ç’¥ ’ß ’£’¨’°’∂’°’±÷á ’¥’´’ª’∏÷Ç’Ø’∏’æ’ù ’°’∂’§÷Ä’°’§’°’º’∂’°’¨’∏’æ ’∫’°’ø’•÷Ä’´÷Å:</p>
                 <p>‘±’∂’Ø’¥’°’∂ ’°’∂’Ø’µ’∏÷Ç’∂’® ($\theta$) ’∫’•’ø÷Ñ ’ß ’¥’•’Æ ’¨’´’∂’´ ’Ø÷Ä’´’ø’´’Ø’°’Ø’°’∂ ’°’∂’Ø’µ’∏÷Ç’∂’´÷Å’ù $$ \\theta > \\arcsin(\\frac{n_2}{n_1}) $$</p>`,
            ru: `<p><strong>–ü–æ–ª–Ω–æ–µ –í–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ –û—Ç—Ä–∞–∂–µ–Ω–∏–µ.</strong> –°–≤–µ—Ç —É–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ —Ü–∏–ª–∏–Ω–¥—Ä–∏—á–µ—Å–∫–æ–≥–æ –≤–æ–ª–æ–∫–Ω–∞.</p>
                 <p>–£—Å–ª–æ–≤–∏–µ: –ø–æ–∫–∞–∑–∞—Ç–µ–ª—å –ø—Ä–µ–ª–æ–º–ª–µ–Ω–∏—è —Å–µ—Ä–¥—Ü–µ–≤–∏–Ω—ã ($n_1$) –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –±–æ–ª—å—à–µ –æ–±–æ–ª–æ—á–∫–∏ ($n_2$).</p>`,
            en: `<p><strong>Total Internal Reflection.</strong> Light travels through the cylindrical core by reflecting off the boundary.</p>
                 <p>Condition: The angle of incidence must exceed the critical angle $$ \\theta_c = \\arcsin(\\frac{n_{clad}}{n_{core}}) $$</p>`
        }
    },
    {
        id: "speaker", icon: "fa-volume-up",
        title: { hy: "16. ‘≤’°÷Ä’±÷Ä’°’≠’∏’Ω", en: "16. Speaker", ru: "16. –î–∏–Ω–∞–º–∏–∫" },
        desc: { hy: "’Å’°’µ’∂’´ ’∏÷Ç’≤’≤’∏÷Ä’§’∏÷Ç’¥", en: "Sound Direction", ru: "–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ó–≤—É–∫–∞" },
        content: {
            hy: `<p><strong>‘ø’∏’∂’°’±÷á ‘¥’´÷Ü’∏÷Ç’¶’∏÷Ä.</strong> ‘ø’∏’∂’´ ’Ø’∏’≤’¥’∂’°’µ’´’∂ ’¥’°’Ø’•÷Ä’•’Ω’®’ù $S = \\pi R l$:</p>
                 <p>‘ø’∏’∂’°’±÷á ’ø’•’Ω÷Ñ’® ’©’°’≤’°’∂’©’´’∂ ’ø’°’¨’´’Ω ’ß ’¥’•’≠’°’∂’´’Ø’°’Ø’°’∂ ’Ø’∏’∑’ø’∏÷Ç’©’µ’∏÷Ç’∂, ’´’∂’π’® ’©’∏÷Ç’µ’¨ ’ß ’ø’°’¨’´’Ω ’∂÷Ä’°’∂ ’ø’°’ø’°’∂’æ’•’¨ ’∏÷Ä’∫’•’Ω ’¥’•’Ø ’°’¥’¢’∏’≤’ª’∏÷Ç’©’µ’∏÷Ç’∂ (piston motion)’ù ’°’º’°’∂÷Å ’§’•÷Ü’∏÷Ä’¥’°÷Å’æ’•’¨’∏÷Ç:</p>`,
            ru: `<p><strong>–ñ–µ—Å—Ç–∫–æ—Å—Ç—å –ö–æ–Ω—É—Å–∞.</strong> –ö–æ–Ω–∏—á–µ—Å–∫–∞—è —Ñ–æ—Ä–º–∞ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –∏–∑–≥–∏–± –¥–∏—Ñ—Ñ—É–∑–æ—Ä–∞ –ø—Ä–∏ –±—ã—Å—Ç—Ä—ã—Ö –∫–æ–ª–µ–±–∞–Ω–∏—è—Ö.</p>
                 <p>–≠—Ç–æ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç —á–∏—Å—Ç–æ—Ç—É –∑–≤—É–∫–∞ –∏ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—É—é –ø–µ—Ä–µ–¥–∞—á—É —ç–Ω–µ—Ä–≥–∏–∏ –æ—Ç –∫–∞—Ç—É—à–∫–∏ –∫ –≤–æ–∑–¥—É—Ö—É.</p>`,
            en: `<p><strong>Conical Diaphragm.</strong> The cone shape provides structural rigidity, allowing the diaphragm to move as a rigid piston.</p>
                 <p>This prevents modal breakup and distortion at high volumes.</p>`
        }
    },
    {
        id: "centrifuge", icon: "fa-dna",
        title: { hy: "17. ’ë’•’∂’ø÷Ä’´÷Ü’∏÷Ç’£", en: "17. Centrifuge", ru: "17. –¶–µ–Ω—Ç—Ä–∏—Ñ—É–≥–∞" },
        desc: { hy: "’Ü’µ’∏÷Ç’©’•÷Ä’´ ’ø’°÷Ä’°’∂’ª’°’ø’∏÷Ç’¥", en: "Separation", ru: "–†–∞–∑–¥–µ–ª–µ–Ω–∏–µ" },
        content: {
            hy: `<p><strong>‘ø’•’∂’ø÷Ä’∏’∂’°’≠’∏÷Ç’µ’Ω ’à÷Ç’™.</strong> ’ä’ø’ø’æ’∏’≤ ’£’¨’°’∂’∏÷Ç’¥ ’¥’°’Ω’∂’´’Ø’∂’•÷Ä’´ ’æ÷Ä’° ’°’¶’§’∏’≤ ’∏÷Ç’™’® ’Ø’°’≠’æ’°’Æ ’ß ’∑’°’º’°’æ’≤’´÷Å ($r$) ÷á ’°’∂’Ø’µ’∏÷Ç’∂’°’µ’´’∂ ’°÷Ä’°’£’∏÷Ç’©’µ’∏÷Ç’∂’´÷Å ($\\omega$):</p>
                 <p>$$ F = m \\omega^2 r $$</p>
                 <p>‘±’æ’•’¨’´ ’Æ’°’∂÷Ä ’¥’°’Ω’∂’´’Ø’∂’•÷Ä’® ’∞’°’æ’°÷Ñ’æ’∏÷Ç’¥ ’•’∂ ’£’¨’°’∂’´ ’∫’°’ø’•÷Ä’´ ’¥’∏’ø (’¥’•’Æ $r$), ’´’Ω’Ø ’©’•’©÷á’∂’•÷Ä’®’ù ’Ø’•’∂’ø÷Ä’∏’∂’∏÷Ç’¥:</p>`,
            ru: `<p><strong>–¶–µ–Ω—Ç—Ä–æ–±–µ–∂–Ω–∞—è –°–∏–ª–∞.</strong> $$ F = m \\omega^2 r $$</p>
                 <p>–í—Ä–∞—â–∞—é—â–∏–π—Å—è —Ü–∏–ª–∏–Ω–¥—Ä —Å–æ–∑–¥–∞–µ—Ç –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—É—é –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—é, –≤ —Ç—ã—Å—è—á–∏ —Ä–∞–∑ –ø—Ä–µ–≤—ã—à–∞—é—â—É—é –∑–µ–º–Ω—É—é, —Ä–∞–∑–¥–µ–ª—è—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –∫—Ä–æ–≤–∏ –∏–ª–∏ –∏–∑–æ—Ç–æ–ø—ã.</p>`,
            en: `<p><strong>Centrifugal Force.</strong> Inside the rotating cylinder, particles experience a force $$ F = m \\omega^2 r $$</p>
                 <p>Denser particles migrate to the outer radius, effectively separating substances based on density.</p>`
        }
    },
    {
        id: "funnel", icon: "fa-filter",
        title: { hy: "18. ’Å’°’£’°÷Ä", en: "18. Funnel", ru: "18. –í–æ—Ä–æ–Ω–∫–∞" },
        desc: { hy: "’Ä’∏’Ω÷Ñ’´ ’Ø’°’º’°’æ’°÷Ä’∏÷Ç’¥", en: "Flow Control", ru: "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ü–æ—Ç–æ–∫–æ–º" },
        content: {
            hy: `<p><strong>’Ä’∏’Ω÷Ñ’´ ‘±÷Ä’°’£’°÷Å’∏÷Ç’¥.</strong> ‘∏’Ω’ø ’°’∂’®’∂’§’∞’°’ø’∏÷Ç’©’µ’°’∂ ’∞’°’æ’°’Ω’°÷Ä’¥’°’∂ ($A_1 v_1 = A_2 v_2$), ’•÷Ä’¢ ’Ø’∏’∂’® ’∂’•’≤’°’∂’∏÷Ç’¥ ’ß, ’∞’•’≤’∏÷Ç’Ø’´ ’°÷Ä’°’£’∏÷Ç’©’µ’∏÷Ç’∂’® ’¥’•’Æ’°’∂’∏÷Ç’¥ ’ß:</p>
                 <p>‘ø’∏’∂’°’±÷á ’¥’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’® ’Ω’°’∞’∏÷Ç’∂ ’Ø’•÷Ä’∫’∏’æ ’∏÷Ç’≤’≤’∏÷Ä’§’∏÷Ç’¥ ’ß ’∞’∏’Ω÷Ñ’® ’§’•’∫’´ ’Ø’•’∂’ø÷Ä’∏’∂:</p>`,
            ru: `<p><strong>–£—Ä–∞–≤–Ω–µ–Ω–∏–µ –ù–µ—Ä–∞–∑—Ä—ã–≤–Ω–æ—Å—Ç–∏.</strong> –°—É–∂–µ–Ω–∏–µ –∫–æ–Ω—É—Å–∞ —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç —Å–∫–æ—Ä–æ—Å—Ç—å –ø–æ—Ç–æ–∫–∞: $$ v_{out} = v_{in} \\cdot (\\frac{R_{in}}{R_{out}})^2 $$</p>
                 <p>–ì–ª–∞–¥–∫–∏–µ —Å—Ç–µ–Ω–∫–∏ –∫–æ–Ω—É—Å–∞ –º–∏–Ω–∏–º–∏–∑–∏—Ä—É—é—Ç —Ç—É—Ä–±—É–ª–µ–Ω—Ç–Ω–æ—Å—Ç—å.</p>`,
            en: `<p><strong>Fluid Dynamics.</strong> According to the continuity equation, as the cross-sectional area decreases in the cone, velocity increases.</p>
                 <p>The conical slope directs fluid to the center with minimal splashing.</p>`
        }
    },
    {
        id: "screw", icon: "fa-water",
        title: { hy: "27. ‘±÷Ä÷Ñ’´’¥’•’§’´ ’ä’ø’∏÷Ç’ø’°’Ø", en: "27. Archimedes Screw", ru: "27. –í–∏–Ω—Ç –ê—Ä—Ö–∏–º–µ–¥–∞" },
        desc: { hy: "’ã÷Ä’´ ’¢’°÷Ä’±÷Ä’°÷Å’∏÷Ç’¥", en: "Water Lifting", ru: "–ü–æ–¥—ä–µ–º –í–æ–¥—ã" },
        content: {
            hy: `<p><strong>’Ä’•’¨’´’Ø’∏’´’§.</strong> ’ç’° ’∫’ø’∏÷Ç’ø’°’Ø’°’±÷á ’¥’°’Ø’•÷Ä÷á’∏÷Ç’µ’© ’ß (Helicoid surface):</p>
                 <p>’ä’ø’ø’æ’•’¨’´’Ω ’°’µ’∂ ’Ω’ø’•’≤’Æ’∏÷Ç’¥ ’ß ÷É’°’Ø ’≠’∏’º’∏’π’∂’•÷Ä ’ª÷Ä’´ ’∞’°’¥’°÷Ä, ’∏÷Ä’∏’∂÷Ñ ’¢’°÷Ä’±÷Ä’°’∂’∏÷Ç’¥ ’•’∂ ’æ’•÷Ä÷á: ’ã÷Ä’´ ’Æ’°’æ’°’¨’® ’¥’•’Ø ’∫’ø’∏÷Ç’µ’ø’∏÷Ç’¥’ù $V \\approx \\pi (R^2 - r^2) \\cdot pitch$:</p>`,
            ru: `<p><strong>–í–∏–Ω—Ç–æ–≤–∞—è –ü–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å.</strong> –ì–µ–ª–∏–∫–æ–∏–¥ –≤–Ω—É—Ç—Ä–∏ —Ç—Ä—É–±—ã.</p>
                 <p>–ü—Ä–∏ –≤—Ä–∞—â–µ–Ω–∏–∏ –≤–∏–Ω—Ç–∞ –≤–æ–¥–∞ –æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è "–∑–∞–ø–µ—Ä—Ç–æ–π" –≤ –Ω–∏–∂–Ω–µ–º –≤–∏—Ç–∫–µ –∏ –º–µ—Ö–∞–Ω–∏—á–µ—Å–∫–∏ –ø–æ–¥–Ω–∏–º–∞–µ—Ç—Å—è –≤–≤–µ—Ä—Ö –ø–æ —Å–ø–∏—Ä–∞–ª–∏.</p>`,
            en: `<p><strong>Helicoid.</strong> A screw-shaped surface inside a cylinder.</p>
                 <p>Rotation traps pockets of water and translates them axially upwards. It's a positive displacement pump mechanism.</p>`
        }
    },
    {
        id: "pottery", icon: "fa-mug-hot",
        title: { hy: "28. ‘ø’°’æ’°’£’∏÷Ä’Æ’∏÷Ç’©’µ’∏÷Ç’∂", en: "28. Pottery", ru: "28. –ì–æ–Ω—á–∞—Ä—Å—Ç–≤–æ" },
        desc: { hy: "’ä’ø’ø’°’Ø’°’∂ ’¥’°÷Ä’¥’´’∂’∂’•÷Ä", en: "Solids of Revolution", ru: "–¢–µ–ª–∞ –í—Ä–∞—â–µ–Ω–∏—è" },
        content: {
            hy: `<p><strong>’ä’ø’ø’°’Ø’°’∂ ’Ñ’°÷Ä’¥’´’∂’∂’•÷Ä.</strong> ‘≤÷Ä’∏÷Ç’ø’°’£’∏÷Ä’Æ’°’Ø’°’∂ ’°’∂’´’æ’® ’∫’ø’ø’æ’∏÷Ç’¥ ’ß ’∞’°’Ω’ø’°’ø’∏÷Ç’∂ ’°÷Ä’°’£’∏÷Ç’©’µ’°’¥’¢:</p>
                 <p>‘ø’°’æ’´ ÷Å’°’∂’Ø’°÷Å’°’Æ ’Ø’•’ø ’£’Æ’∏÷Ç’¥ ’ß ’∑÷Ä’ª’°’∂’°’£’´’Æ: ‘±÷Ä’§’µ’∏÷Ç’∂÷Ñ’∏÷Ç’¥ ’Ω’ø’°÷Å’æ’°’Æ ’¥’°÷Ä’¥’∂’´ ’Æ’°’æ’°’¨’® ’Ø’°÷Ä’•’¨’´ ’ß ’∞’°’∑’æ’•’¨ ’´’∂’ø’•’£÷Ä’°’¨’∏’æ’ù $$ V = \\pi \\int f(x)^2 dx $$</p>`,
            ru: `<p><strong>–¢–µ–ª–∞ –í—Ä–∞—â–µ–Ω–∏—è.</strong> –ü—Ä–æ—Ü–µ—Å—Å —Å–æ–∑–¥–∞–Ω–∏—è –∫–µ—Ä–∞–º–∏–∫–∏ ‚Äî —ç—Ç–æ —Ñ–∏–∑–∏—á–µ—Å–∫–æ–µ –≤–æ–ø–ª–æ—â–µ–Ω–∏–µ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –≤—Ä–∞—â–µ–Ω–∏—è –∫—Ä–∏–≤–æ–π –≤–æ–∫—Ä—É–≥ –æ—Å–∏.</p>
                 <p>–°–∏–ª–∞ —Ä—É–∫ –≥–æ–Ω—á–∞—Ä–∞ —Ñ–æ—Ä–º–∏—Ä—É–µ—Ç –ø—Ä–æ—Ñ–∏–ª—å $f(x)$, –∞ –≤—Ä–∞—â–µ–Ω–∏–µ –∫—Ä—É–≥–∞ —Å–æ–∑–¥–∞–µ—Ç –æ–±—ä–µ–º.</p>`,
            en: `<p><strong>Solids of Revolution.</strong> Pottery is the practical application of generating solids of revolution.</p>
                 <p>The potter shapes a profile curve $y=f(x)$, and the wheel's rotation creates a symmetric body with circular cross-sections.</p>`
        }
    },
    {
        id: "turbine", icon: "fa-fan",
        title: { hy: "29. ’è’∏÷Ç÷Ä’¢’´’∂", en: "29. Turbine", ru: "29. –¢—É—Ä–±–∏–Ω–∞" },
        desc: { hy: "‘∑’∂’•÷Ä’£’´’°’µ’´ ÷É’∏’≠’°’Ø’•÷Ä’∫’∏÷Ç’¥", en: "Energy Conversion", ru: "–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≠–Ω–µ—Ä–≥–∏–∏" },
        content: {
            hy: `<p><strong>‘±’•÷Ä’∏’§’´’∂’°’¥’´’Ø’°.</strong> ’è’∏÷Ç÷Ä’¢’´’∂’´ ’©’´’°’Ø’∂’•÷Ä’® ’∫’ø’ø’æ’∏÷Ç’¥ ’•’∂ ’∞’•’≤’∏÷Ç’Ø’´ ’Ø’°’¥ ’£’°’¶’´ ’∞’∏’Ω÷Ñ’´ ’°’¶’§’•÷Å’∏÷Ç’©’µ’°’¥’¢:</p>
                 <p>’ä’ø’ø’∏’≤ ’¥’∏’¥’•’∂’ø’®’ù $\\tau = r \\times F$: ‘π’´’°’Ø’∂’•÷Ä’´ ’Ø’∏÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’® (airfoil shape) ÷Ö’∫’ø’´’¥’°’¨’°÷Å’æ’°’Æ ’ß ’°’º’°’æ’•’¨’°’£’∏÷Ç’µ’∂ ’ß’∂’•÷Ä’£’´’° ’Ω’ø’°’∂’°’¨’∏÷Ç ’∞’°’¥’°÷Ä (‘≤’•’º’∂’∏÷Ç’¨’´’´ ÷Ö÷Ä’•’∂÷Ñ):</p>`,
            ru: `<p><strong>–í—Ä–∞—â–∞—é—â–∏–π –ú–æ–º–µ–Ω—Ç.</strong> –õ–æ–ø–∞—Ç–∫–∏ —Ç—É—Ä–±–∏–Ω—ã –ø—Ä–µ–æ–±—Ä–∞–∑—É—é—Ç –∫–∏–Ω–µ—Ç–∏—á–µ—Å–∫—É—é —ç–Ω–µ—Ä–≥–∏—é –ø–æ—Ç–æ–∫–∞ –≤–æ –≤—Ä–∞—â–µ–Ω–∏–µ —Ä–æ—Ç–æ—Ä–∞.</p>
                 <p>–§–æ—Ä–º–∞ –ª–æ–ø–∞—Ç–æ–∫ —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è –º–µ—Ç–æ–¥–∞–º–∏ –≥–∏–¥—Ä–æ–¥–∏–Ω–∞–º–∏–∫–∏ –¥–ª—è –º–∞–∫—Å–∏–º–∏–∑–∞—Ü–∏–∏ –ö–ü–î.</p>`,
            en: `<p><strong>Torque Generation.</strong> Fluid flow exerts force on the angled blades, creating torque $\\tau = r \\times F$.</p>
                 <p>The rotational energy is then converted into electricity by a generator attached to the shaft.</p>`
        }
    },
    {
        id: "capsule", icon: "fa-rocket",
        title: { hy: "30. ’è’´’•’¶’•÷Ä’°’∂’°’æ", en: "30. Space Capsule", ru: "30. –ö–æ—Å–º–∏—á–µ—Å–∫–∞—è –ö–∞–ø—Å—É–ª–∞" },
        desc: { hy: "’é’°’µ÷Ä’ß’ª÷Ñ", en: "Re-entry", ru: "–í—Ö–æ–¥ –≤ –ê—Ç–º–æ—Å—Ñ–µ—Ä—É" },
        content: {
            hy: `<p><strong>‘≤’∏÷Ç’© ’Ñ’°÷Ä’¥’´’∂ (Blunt Body).</strong> ’è’´’•’¶’•÷Ä’°’∂’°’æ’´ ’∞’°’ø’°’Ø’® ’£’∂’§’°’µ’´’∂ ’Ω’•’£’¥’•’∂’ø ’ß ($R_{large}$):</p>
                 <p>‘±’µ’Ω ’±÷á’® ’Ω’ø’•’≤’Æ’∏÷Ç’¥ ’ß ’∞’°÷Ä’æ’°’Æ’°’µ’´’∂ ’°’¨’´÷Ñ (shock wave), ’∏÷Ä’® ’∞’•’º’∏÷Ç ’ß ’∫’°’∞’∏÷Ç’¥ ’∫’¨’°’¶’¥’°’∂ ’¥’°’Ø’•÷Ä÷á’∏÷Ç’µ’©’´÷Å’ù ’∫’°’∑’ø’∫’°’∂’•’¨’∏’æ ’°’µ÷Ä’æ’•’¨’∏÷Ç÷Å: ‘ø’∏’∂’°’±÷á ’¥’°’Ω’® ’°’∫’°’∞’∏’æ’∏÷Ç’¥ ’ß ’°’•÷Ä’∏’§’´’∂’°’¥’´’Ø ’Ø’°’µ’∏÷Ç’∂’∏÷Ç’©’µ’∏÷Ç’∂:</p>`,
            ru: `<p><strong>–¢—É–ø–æ–µ –¢–µ–ª–æ.</strong> –°—Ñ–µ—Ä–∏—á–µ—Å–∫–æ–µ –¥–Ω–æ —Å–æ–∑–¥–∞–µ—Ç –æ—Ç–æ—à–µ–¥—à—É—é —É–¥–∞—Ä–Ω—É—é –≤–æ–ª–Ω—É.</p>
                 <p>–≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç —Ä–∞—Å—Å–µ–∏–≤–∞—Ç—å 90% —Ç–µ–ø–ª–∞ –≤ –∞—Ç–º–æ—Å—Ñ–µ—Ä—É, –∞ –Ω–µ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å –µ–≥–æ –∫–æ—Ä–ø—É—Å—É –∫–æ—Ä–∞–±–ª—è. –ö–æ–Ω–∏—á–µ—Å–∫–∞—è —Ñ–æ—Ä–º–∞ —Å—Ç–∞–±–∏–ª–∏–∑–∏—Ä—É–µ—Ç —Å–ø—É—Å–∫.</p>`,
            en: `<p><strong>Blunt Body Theory.</strong> The spherical base creates a detached shock wave.</p>
                 <p>This dissipates most of the kinetic energy as heat into the air, protecting the capsule. The frustum shape ensures aerodynamic stability during hypersonic re-entry.</p>`
        }
    }
];

function renderApps() {
    const grid = document.getElementById('appGrid');
    if (!grid) return;
    grid.innerHTML = '';
    appData.forEach(app => {
        const title = app.title[currentLang] || app.title['en'];
        const desc = app.desc[currentLang] || app.desc['en'];
        grid.innerHTML += `
            <div class="app-card" onclick="openAppDetail('${app.id}')">
                <div class="app-card-img"><i class="fas ${app.icon}"></i></div>
                <div class="app-card-content"><h3>${title}</h3><p>${desc}</p></div>
            </div>
        `;
    });
}

window.openAppDetail = function (id) {
    const modal = document.getElementById('appModal');
    const body = document.getElementById('modalBody');
    const app = appData.find(a => a.id === id);
    const title = app.title[currentLang] || app.title['en'];
    const content = app.content[currentLang] || app.content['en'];
    body.innerHTML = `<h2>${title}</h2>${content}`;
    modal.style.display = 'flex';
    if (window.MathJax) MathJax.typesetPromise([body]);
};

window.closeAppDetail = function () {
    document.getElementById('appModal').style.display = 'none';
};

// --- Calculator Logic ---
// --- Calculator Logic ---
// Helper function to format with pi symbol and numerical value
function formatWithPi(symbolicExpr, numericalValue) {
    return `$$${symbolicExpr}$$<br><small style="opacity:0.75;">(‚âà ${numericalValue.toFixed(4)})</small>`;
}

const calcShapes = {
    cylinder: {
        inputs: ['R', 'H'],
        calc: (R, H) => {
            const Sk_coef = 2 * R * H;
            const Sl_coef = 2 * R * (R + H);
            const V_coef = R ** 2 * H;

            return formatWithPi(`S_k = 2\\pi RH = ${Sk_coef.toFixed(2)}\\pi`, Sk_coef * Math.PI) + '<br>' +
                formatWithPi(`S_l = 2\\pi R(R + H) = ${Sl_coef.toFixed(2)}\\pi`, Sl_coef * Math.PI) + '<br>' +
                formatWithPi(`V = \\pi R^2H = ${V_coef.toFixed(2)}\\pi`, V_coef * Math.PI);
        }
    },
    cone: {
        inputs: ['R', 'H'],
        calc: (R, H) => {
            const l = Math.sqrt(R ** 2 + H ** 2);
            const Sk_coef = R * l;
            const Sl_coef = R * (R + l);
            const V_coef = (R ** 2 * H) / 3;

            return formatWithPi(`S_k = \\pi Rl = ${Sk_coef.toFixed(2)}\\pi`, Sk_coef * Math.PI) + '<br>' +
                formatWithPi(`S_l = \\pi R(R + l) = ${Sl_coef.toFixed(2)}\\pi`, Sl_coef * Math.PI) + '<br>' +
                formatWithPi(`V = \\frac{1}{3}\\pi R^2H = ${V_coef.toFixed(2)}\\pi`, V_coef * Math.PI);
        }
    },
    frustum: {
        inputs: ['R', 'r', 'H'],
        calc: (R, r, H) => {
            const l = Math.sqrt((R - r) ** 2 + H ** 2);
            const Sk_coef = (R + r) * l;
            const Sl_coef = (R + r) * l + R ** 2 + r ** 2;
            const V_coef = (H * (R ** 2 + r ** 2 + R * r)) / 3;

            return formatWithPi(`S_k = \\pi(R + r)l = ${Sk_coef.toFixed(2)}\\pi`, Sk_coef * Math.PI) + '<br>' +
                formatWithPi(`S_l = \\pi[(R+r)l + R^2 + r^2] = ${Sl_coef.toFixed(2)}\\pi`, Sl_coef * Math.PI) + '<br>' +
                formatWithPi(`V = \\frac{1}{3}\\pi H(R^2 + r^2 + Rr) = ${V_coef.toFixed(2)}\\pi`, V_coef * Math.PI);
        }
    },
    sphere: {
        inputs: ['R'],
        calc: (R) => {
            const S_coef = 4 * R ** 2;
            const V_coef = (4 * R ** 3) / 3;

            return formatWithPi(`S = 4\\pi R^2 = ${S_coef.toFixed(2)}\\pi`, S_coef * Math.PI) + '<br>' +
                formatWithPi(`V = \\frac{4}{3}\\pi R^3 = ${V_coef.toFixed(2)}\\pi`, V_coef * Math.PI);
        }
    },
    segment: {
        inputs: ['R', 'h'],
        calc: (R, h) => {
            const Sk_coef = 2 * R * h;
            const V_coef = h ** 2 * (R - h / 3);

            return formatWithPi(`S_k = 2\\pi Rh = ${Sk_coef.toFixed(2)}\\pi`, Sk_coef * Math.PI) + '<br>' +
                formatWithPi(`V = \\pi h^2(R - \\frac{h}{3}) = ${V_coef.toFixed(2)}\\pi`, V_coef * Math.PI);
        }
    },
    sector: {
        inputs: ['R', 'h'],
        calc: (R, h) => {
            const V_coef = (2 * R ** 2 * h) / 3;

            return formatWithPi(`V = \\frac{2}{3}\\pi R^2h = ${V_coef.toFixed(2)}\\pi`, V_coef * Math.PI);
        }
    },
    layer: {
        inputs: ['r1', 'r2', 'h'],
        calc: (r1, r2, h) => {
            const Sk_coef = 2 * Math.sqrt((r1 ** 2 + r2 ** 2) / 2) * h;
            const V_coef = (h * (3 * r1 ** 2 + 3 * r2 ** 2 + h ** 2)) / 6;

            return formatWithPi(`S_k \\approx ${Sk_coef.toFixed(2)}\\pi`, Sk_coef * Math.PI) + '<br>' +
                formatWithPi(`V = \\frac{1}{6}\\pi h(3r_1^2 + 3r_2^2 + h^2) = ${V_coef.toFixed(2)}\\pi`, V_coef * Math.PI);
        }
    },
    zone: {
        inputs: ['R', 'H'],
        calc: (R, H) => {
            const S_coef = 2 * R * H;

            return formatWithPi(`S_k = 2\\pi RH = ${S_coef.toFixed(2)}\\pi`, S_coef * Math.PI);
        }
    }
};

// Helper function to format with pi symbol and numerical value
const varDescriptions = {
    hy: {
        R: '’∑’°’º’°’æ’´’≤',
        H: '’¢’°÷Ä’±÷Ä’∏÷Ç’©’µ’∏÷Ç’∂',
        r: '÷É’∏÷Ñ÷Ä ’∑’°’º’°’æ’´’≤',
        r1: '’æ’•÷Ä’´’∂ ’∑’°’º’°’æ’´’≤',
        r2: '’Ω’ø’∏÷Ä’´’∂ ’∑’°’º’°’æ’´’≤',
        h: '’¢’°÷Ä’±÷Ä’∏÷Ç’©’µ’∏÷Ç’∂'
    },
    ru: {
        R: '—Ä–∞–¥–∏—É—Å',
        H: '–≤—ã—Å–æ—Ç–∞',
        r: '–º–∞–ª—ã–π —Ä–∞–¥–∏—É—Å',
        r1: '–≤–µ—Ä—Ö–Ω–∏–π —Ä–∞–¥–∏—É—Å',
        r2: '–Ω–∏–∂–Ω–∏–π —Ä–∞–¥–∏—É—Å',
        h: '–≤—ã—Å–æ—Ç–∞'
    },
    en: {
        R: 'radius',
        H: 'height',
        r: 'small radius',
        r1: 'top radius',
        r2: 'bottom radius',
        h: 'height'
    }
};

// Helper function to parse mathematical expressions (supports œÄ, sqrt, trig, log, etc.)
function parseExpression(expr) {
    if (!expr || expr.trim() === '') return NaN;
    try {
        let processedExpr = expr;

        // Replace œÄ with Math.PI
        processedExpr = processedExpr.replace(/œÄ/g, 'Math.PI').replace(/pi/gi, 'Math.PI');

        // Replace e (Euler's number) - be careful not to replace 'e' in function names
        processedExpr = processedExpr.replace(/\be\b/g, 'Math.E');

        // Replace ‚àö with Math.sqrt
        processedExpr = processedExpr.replace(/‚àö\(([^)]+)\)/g, 'Math.sqrt($1)');
        processedExpr = processedExpr.replace(/‚àö([0-9.]+)/g, 'Math.sqrt($1)');

        // Replace trigonometric functions
        processedExpr = processedExpr.replace(/sin\(/g, 'Math.sin(');
        processedExpr = processedExpr.replace(/cos\(/g, 'Math.cos(');
        processedExpr = processedExpr.replace(/tan\(/g, 'Math.tan(');
        processedExpr = processedExpr.replace(/asin\(/g, 'Math.asin(');
        processedExpr = processedExpr.replace(/acos\(/g, 'Math.acos(');
        processedExpr = processedExpr.replace(/atan\(/g, 'Math.atan(');

        // Replace logarithms
        processedExpr = processedExpr.replace(/ln\(/g, 'Math.log(');
        processedExpr = processedExpr.replace(/log\(/g, 'Math.log10(');

        // Replace absolute value |x| with Math.abs(x)
        processedExpr = processedExpr.replace(/\|([^|]+)\|/g, 'Math.abs($1)');

        // Replace power notation: x¬≤ ‚Üí x**2, x¬≥ ‚Üí x**3
        processedExpr = processedExpr.replace(/([0-9a-zA-Z.)])\s*¬≤/g, '$1**2');
        processedExpr = processedExpr.replace(/([0-9a-zA-Z.)])\s*¬≥/g, '$1**3');

        // Replace factorial (simple implementation for small numbers)
        processedExpr = processedExpr.replace(/(\d+)!/g, (match, num) => {
            const n = parseInt(num);
            if (n > 170) return 'Infinity'; // Factorial overflow
            let result = 1;
            for (let i = 2; i <= n; i++) result *= i;
            return result;
        });

        // Safely evaluate
        const result = Function('"use strict"; return (' + processedExpr + ')')();
        return parseFloat(result);
    } catch (e) {
        console.error('Parse error:', e);
        return parseFloat(expr); // fallback to regular parsing
    }
}

window.updateCalcInputs = function () {
    const type = document.getElementById('shapeSelect').value;
    const container = document.getElementById('calcInputs');
    container.innerHTML = '';
    if (calcShapes[type]) {
        calcShapes[type].inputs.forEach((l, i) => {
            const desc = varDescriptions[currentLang][l] ? ` (${varDescriptions[currentLang][l]})` : '';
            container.innerHTML += `<label>${l}${desc}:</label><input type="text" inputmode="decimal" id="inp_${i}" placeholder="÷Ö÷Ä. 5, œÄ, ‚àö2">`;
        });
    }
    document.getElementById('calcResult').innerHTML = '';
};

window.calculate = function () {
    const type = document.getElementById('shapeSelect').value;
    const inputs = calcShapes[type].inputs.map((_, i) => {
        const val = document.getElementById(`inp_${i}`).value;
        return parseExpression(val);
    });
    if (inputs.some(isNaN)) {
        document.getElementById('calcResult').innerHTML = '<p style="color: #ff5252;">‚ö† ‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ’¥’∏÷Ç’ø÷Ñ’°’£÷Ä’•’¨ ’æ’°’æ’•÷Ä ’©’æ’•÷Ä</p>';
        return;
    }
    const result = calcShapes[type].calc(...inputs);
    document.getElementById('calcResult').innerHTML = result;
    // Render MathJax
    if (window.MathJax && MathJax.typesetPromise) {
        MathJax.typesetPromise([document.getElementById('calcResult')]).catch((err) => console.error('MathJax error:', err));
    }
};

// --- 3D Logic ---
let scene, camera, renderer, currentMesh, controls, clippingPlane;
function init3D() {
    const container = document.getElementById('canvas-container');
    if (!container) return;
    scene = new THREE.Scene();
    // Set camera with temporary aspect; we'll update it after measuring container
    // Use a lower minimum so very small mobile viewports don't force incorrect aspect
    const cw = Math.max(240, container.clientWidth || window.innerWidth);
    const ch = Math.max(240, container.clientHeight || (window.innerHeight - 140));
    camera = new THREE.PerspectiveCamera(45, cw / ch, 0.1, 1000);
    camera.position.set(8, 8, 12);
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    // Size renderer to container dimensions so it fits on mobile
    renderer.setSize(cw, ch);
    renderer.domElement.style.width = '100%';
    renderer.domElement.style.height = '100%';
    renderer.localClippingEnabled = true;
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);
    scene.add(new THREE.AmbientLight(0x404040, 1.5));
    const dl = new THREE.DirectionalLight(0xffffff, 1);
    dl.position.set(10, 20, 10);
    dl.castShadow = true;
    scene.add(dl);
    // Set grid color based on theme
    let gridColor, gridColor2;
    if (document.documentElement.getAttribute('data-theme') === 'light') {
        gridColor = 0x111111; // black
        gridColor2 = 0x333333;
    } else {
        gridColor = 0x888888; // gray
        gridColor2 = 0xcccccc;
    }
    scene.add(new THREE.GridHelper(20, 20, gridColor, gridColor2));
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    // Removed clipping plane to allow full Y movement
    clippingPlane = null;
    window.changeModel();
    animate();
}

// Resize handler to keep renderer/camera in sync with container size
function handleResize() {
    const container = document.getElementById('canvas-container');
    if (!container || !renderer || !camera) return;
    const w = Math.max(240, container.clientWidth);
    const h = Math.max(240, container.clientHeight || Math.max(window.innerHeight - 140, 300));
    renderer.setSize(w, h);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
}

window.addEventListener('resize', () => {
    // small debounce
    clearTimeout(window._resizeTimeout);
    window._resizeTimeout = setTimeout(() => {
        handleResize();
    }, 150);
});

function createMesh(geo, col) {
    // Properly dispose of existing mesh/group
    if (currentMesh) {
        scene.remove(currentMesh);
        if (currentMesh.type === 'Group') {
            // Dispose all geometries and materials in group
            currentMesh.traverse((child) => {
                if (child.isMesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                }
            });
        } else {
            // Single mesh disposal
            if (currentMesh.geometry) currentMesh.geometry.dispose();
            if (currentMesh.material) currentMesh.material.dispose();
        }
    }
    const mat = new THREE.MeshPhongMaterial({
        color: col, side: THREE.DoubleSide, clippingPlanes: clippingPlane ? [clippingPlane] : [], clipShadows: true, shininess: 80
    });
    currentMesh = new THREE.Mesh(geo, mat);
    currentMesh.castShadow = true;
    currentMesh.receiveShadow = true;
    window.updatePosition();
    scene.add(currentMesh);
}

window.changeModel = function () {
    const type = document.getElementById('modelType').value;
    const col = document.getElementById('meshColor').value;
    const p = document.getElementById('dynamicParams');
    p.innerHTML = '';
    let geo;
    if (type === 'cylinder') {
        geo = new THREE.CylinderGeometry(2, 2, 4, 64);
        addSlider(p, 'R', 0.5, 5, 2, v => updateGeo('cyl', v, null));
        addSlider(p, 'H', 1, 10, 4, v => updateGeo('cyl', null, v));
    } else if (type === 'cone') {
        geo = new THREE.ConeGeometry(2, 4, 64);
        addSlider(p, 'R', 0.5, 5, 2, v => updateGeo('cone', v, null));
        addSlider(p, 'H', 1, 10, 4, v => updateGeo('cone', null, v));
    } else if (type === 'frustum') {
        geo = new THREE.CylinderGeometry(2, 4, 4, 64);
        addSlider(p, 'r_top', 0.1, 5, 2, v => updateGeo('frust', v, null, null));
        addSlider(p, 'r_bot', 0.1, 5, 4, v => updateGeo('frust', null, null, v));
        addSlider(p, 'H', 1, 10, 4, v => updateGeo('frust', null, v, null));
    } else if (type === 'sphere') {
        geo = new THREE.SphereGeometry(2, 64, 64);
        addSlider(p, 'R', 0.5, 5, 2, v => updateGeo('sph', v));
    } else if (type === 'segment') {
        // Spherical segment: partial sphere (cut by a plane)
        geo = new THREE.SphereGeometry(3, 64, 64, 0, Math.PI * 2, 0, Math.PI * 0.5);
        addSlider(p, 'R', 0.5, 5, 3, v => updateGeo('segment', v, null));
        addSlider(p, 'h', 0.1, 3, 1.5, v => updateGeo('segment', null, v));
    } else if (type === 'sector') {
        // Spherical sector: segment + cone from center - create group
        const R = 3, h = 1.5;
        const thetaLen = Math.PI * 0.5;
        const segGeo = new THREE.SphereGeometry(R, 64, 64, 0, Math.PI * 2, 0, thetaLen);
        const baseRadius = R * Math.sin(thetaLen);
        const coneHeight = R * Math.cos(thetaLen);
        const coneGeo = new THREE.ConeGeometry(baseRadius, R - coneHeight, 64);
        const group = new THREE.Group();
        const segMat = new THREE.MeshPhongMaterial({ color: col, side: THREE.DoubleSide, shininess: 80, wireframe: window._wireframeState || false });
        const coneMat = new THREE.MeshPhongMaterial({ color: col, side: THREE.DoubleSide, shininess: 80, wireframe: window._wireframeState || false });
        const segMesh = new THREE.Mesh(segGeo, segMat);
        const coneMesh = new THREE.Mesh(coneGeo, coneMat);
        coneMesh.rotation.x = Math.PI; // Point upward
        coneMesh.position.y = -(R - coneHeight) / 2; // Position so apex at origin, base at segment base
        group.add(coneMesh);
        group.add(segMesh);
        // For sector we use a group instead of single geometry
        if (currentMesh) {
            scene.remove(currentMesh);
            if (currentMesh.type === 'Group') {
                currentMesh.traverse((child) => {
                    if (child.isMesh) {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    }
                });
            }
        }
        currentMesh = group;
        currentMesh.castShadow = true;
        scene.add(currentMesh);
        window.updatePosition();
        addSlider(p, 'R', 0.5, 5, 3, v => updateGeo('sector', v, null));
        addSlider(p, 'h', 0.1, 3, 1.5, v => updateGeo('sector', null, v));
        geo = null; // Skip normal mesh creation
    } else if (type === 'zone') {
        // Spherical zone: band between two planes
        geo = new THREE.SphereGeometry(3, 64, 64, 0, Math.PI * 2, Math.PI * 0.35, Math.PI * 0.3);
        addSlider(p, 'R', 0.5, 5, 3, v => updateGeo('zone', v, null));
        addSlider(p, 'H', 0.1, 2, 0.9, v => updateGeo('zone', null, v));
    } else if (type === 'layer') {
        // Spherical layer: band with top and bottom circles
        const R = 3, r1 = 2.5, r2 = 2.8, h = 2.4;
        const thetaStart = Math.PI * 0.3;
        const thetaLen = Math.PI * 0.4;
        const bandGeo = new THREE.SphereGeometry(R, 64, 64, 0, Math.PI * 2, thetaStart, thetaLen);
        const group = new THREE.Group();
        const bandMat = new THREE.MeshPhongMaterial({ color: col, side: THREE.DoubleSide, shininess: 80, wireframe: window._wireframeState || false });
        const bandMesh = new THREE.Mesh(bandGeo, bandMat);
        // Calculate circle positions based on sphere geometry
        const yTop = R * Math.cos(thetaStart);
        const yBottom = R * Math.cos(thetaStart + thetaLen);
        const rTop = R * Math.sin(thetaStart);
        const rBottom = R * Math.sin(thetaStart + thetaLen);
        const circleGeo1 = new THREE.CircleGeometry(rTop, 64);
        const circleGeo2 = new THREE.CircleGeometry(rBottom, 64);
        const circleMat = new THREE.MeshPhongMaterial({ color: col, side: THREE.DoubleSide, wireframe: window._wireframeState || false });
        const circle1 = new THREE.Mesh(circleGeo1, circleMat);
        const circle2 = new THREE.Mesh(circleGeo2, circleMat);
        circle1.rotation.x = -Math.PI / 2;
        circle1.position.y = yTop;
        circle2.rotation.x = -Math.PI / 2;
        circle2.position.y = yBottom;
        group.add(bandMesh);
        group.add(circle1);
        group.add(circle2);
        if (currentMesh) {
            scene.remove(currentMesh);
            if (currentMesh.type === 'Group') {
                currentMesh.traverse((child) => {
                    if (child.isMesh) {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    }
                });
            }
        }
        currentMesh = group;
        currentMesh.castShadow = true;
        scene.add(currentMesh);
        window.updatePosition();
        addSlider(p, 'r1', 0.5, 5, 2.5, v => updateGeo('layer', v, null, null));
        addSlider(p, 'r2', 0.5, 5, 2.8, v => updateGeo('layer', null, v, null));
        addSlider(p, 'h', 0.1, 3, 2.4, v => updateGeo('layer', null, null, v));
        geo = null; // Skip normal mesh creation
    }
    // Add X, Y, Z position controls
    const posDiv = document.createElement('div');
    posDiv.style.marginTop = '18px';
    posDiv.innerHTML = '<label style="font-weight:bold;">’è’•’≤’°’∑’°÷Ä’™ (Move):</label>';
    addSlider(posDiv, 'X', -5, 5, 0, v => updatePositionInput('x', v));
    addSlider(posDiv, 'Y', -5, 5, 0, v => updatePositionInput('y', v));
    addSlider(posDiv, 'Z', -5, 5, 0, v => updatePositionInput('z', v));
    p.appendChild(posDiv);
    // Info box for computed properties
    let infoBox = document.getElementById('modelInfoBox');
    if (!infoBox) {
        infoBox = document.createElement('div');
        infoBox.id = 'modelInfoBox';
        infoBox.style.marginTop = '18px';
        infoBox.style.background = 'rgba(255,255,255,0.08)';
        infoBox.style.padding = '12px 18px';
        infoBox.style.borderRadius = '10px';
        infoBox.style.fontSize = '1.05em';
        infoBox.style.lineHeight = '1.7';
        p.parentNode.insertBefore(infoBox, p.nextSibling);
    }
    // Store infoBox for later updates
    window._modelInfoBox = infoBox;
    if (geo) createMesh(geo, col); // Only create mesh if geo is not null
    // Set initial position
    updatePositionInput('x', 0);
    updatePositionInput('y', 0);
    updatePositionInput('z', 0);
    // Show initial info
    updateModelInfoBox();
};

// Update info box with computed properties
function updateModelInfoBox() {
    if (!window._modelInfoBox) return;
    const type = document.getElementById('modelType').value;
    const t = (translations[currentLang] || translations['en']);
    let html = '';
    if (type === 'cylinder') {
        const R = p1, H = p2;
        const S_side = 2 * Math.PI * R * H;
        const S_total = 2 * Math.PI * R * (H + R);
        const V = Math.PI * R * R * H;
        html = `<b>${t.info_side_area}</b> ${S_side.toFixed(3)}<br><b>${t.info_total_area}</b> ${S_total.toFixed(3)}<br><b>${t.info_volume}</b> ${V.toFixed(3)}`;
    } else if (type === 'cone') {
        const R = p1, H = p2;
        const l = Math.sqrt(R * R + H * H);
        const S_side = Math.PI * R * l;
        const S_total = Math.PI * R * (l + R);
        const V = (1 / 3) * Math.PI * R * R * H;
        html = `<b>${t.info_slant}</b> ${l.toFixed(3)}<br><b>${t.info_side_area}</b> ${S_side.toFixed(3)}<br><b>${t.info_total_area}</b> ${S_total.toFixed(3)}<br><b>${t.info_volume}</b> ${V.toFixed(3)}`;
    } else if (type === 'frustum') {
        const R = p1, r = p3, H = p2;
        const l = Math.sqrt((R - r) * (R - r) + H * H);
        const S_side = Math.PI * (R + r) * l;
        const S_total = S_side + Math.PI * R * R + Math.PI * r * r;
        const V = (1 / 3) * Math.PI * H * (R * R + r * r + R * r);
        html = `<b>${t.info_slant}</b> ${l.toFixed(3)}<br><b>${t.info_side_area}</b> ${S_side.toFixed(3)}<br><b>${t.info_total_area}</b> ${S_total.toFixed(3)}<br><b>${t.info_volume}</b> ${V.toFixed(3)}`;
    } else if (type === 'sphere') {
        const R = p1;
        const S = 4 * Math.PI * R * R;
        const V = (4 / 3) * Math.PI * R * R * R;
        html = `<b>${t.info_surface}</b> ${S.toFixed(3)}<br><b>${t.info_volume}</b> ${V.toFixed(3)}`;
    } else if (type === 'segment') {
        const R = p1, h = p2;
        const S_k = 2 * Math.PI * R * h;
        const V = Math.PI * h * h * (R - h / 3);
        html = `<b>$S_k$:</b> ${S_k.toFixed(3)}<br><b>$V$:</b> ${V.toFixed(3)}`;
    } else if (type === 'sector') {
        const R = p1, h = p2;
        const V = (2 / 3) * Math.PI * R * R * h;
        html = `<b>$V$:</b> ${V.toFixed(3)}`;
    } else if (type === 'zone') {
        const R = p1, H = p2;
        const S_k = 2 * Math.PI * R * H;
        html = `<b>$S_k$:</b> ${S_k.toFixed(3)}`;
    } else if (type === 'layer') {
        const r1 = p1, r2 = p2, h = p3;
        const S_k = 2 * Math.PI * Math.sqrt((r1 * r1 + r2 * r2) / 2) * h;
        const V = (1 / 6) * Math.PI * h * (3 * r1 * r1 + 3 * r2 * r2 + h * h);
        html = `<b>$S_k \\approx$:</b> ${S_k.toFixed(3)}<br><b>$V$:</b> ${V.toFixed(3)}`;
    }
    window._modelInfoBox.innerHTML = html;
    if (window.MathJax && MathJax.typesetPromise) {
        MathJax.typesetPromise([window._modelInfoBox]).catch(() => { });
    }
}

// Store position state
let modelPos = { x: 0, y: 0, z: 0 };
function updatePositionInput(axis, value) {
    modelPos[axis] = value;
    window.updatePosition();
}
function addSlider(parent, label, min, max, val, cb) {
    const d = document.createElement('div');
    d.style.display = 'flex';
    d.style.alignItems = 'center';
    d.style.gap = '10px';
    d.innerHTML = `<label style="min-width:2.5em;">${label}</label>` +
        `<input type="range" min="${min}" max="${max}" step="0.01" value="${val}" style="flex:1;">` +
        `<input type="number" min="${min}" max="${max}" step="0.01" value="${val}" style="width:4em;">`;
    const range = d.querySelector('input[type=range]');
    const number = d.querySelector('input[type=number]');
    range.oninput = e => { number.value = range.value; cb(parseFloat(range.value)); };
    number.oninput = e => { range.value = number.value; cb(parseFloat(number.value)); };
    parent.appendChild(d);
}

let p1 = 2, p2 = 4, p3 = 4;
function updateGeo(t, v1, v2, v3) {
    if (v1 !== null) p1 = v1; if (v2 !== null) p2 = v2; if (v3 !== null) p3 = v3;
    let g;
    if (t === 'cyl') g = new THREE.CylinderGeometry(p1, p1, p2, 64);
    if (t === 'cone') g = new THREE.ConeGeometry(p1, p2, 64);
    if (t === 'frust') g = new THREE.CylinderGeometry(p1, p3, p2, 64);
    if (t === 'sph') g = new THREE.SphereGeometry(p1, 64, 64);
    if (t === 'segment') {
        // p1=R, p2=h; thetaLength based on h
        const thetaLen = Math.min(Math.PI, Math.acos(1 - p2 / p1));
        g = new THREE.SphereGeometry(p1, 64, 64, 0, Math.PI * 2, 0, thetaLen);
    }
    if (t === 'sector') {
        // Recreate group for sector
        if (currentMesh) {
            scene.remove(currentMesh);
            if (currentMesh.type === 'Group') {
                currentMesh.traverse((child) => {
                    if (child.isMesh) {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    }
                });
            }
        }
        const group = new THREE.Group();
        const thetaLen = Math.min(Math.PI, Math.acos(1 - p2 / p1));
        const segGeo = new THREE.SphereGeometry(p1, 64, 64, 0, Math.PI * 2, 0, thetaLen);
        const baseRadius = p1 * Math.sin(thetaLen);
        const coneHeight = p1 * Math.cos(thetaLen);
        const actualConeHeight = p1 - coneHeight;
        const coneGeo = new THREE.ConeGeometry(baseRadius, actualConeHeight, 64);
        const col = document.getElementById('meshColor').value;
        const wf = window._wireframeState || false;
        const segMat = new THREE.MeshPhongMaterial({ color: col, side: THREE.DoubleSide, shininess: 80, wireframe: wf });
        const coneMat = new THREE.MeshPhongMaterial({ color: col, side: THREE.DoubleSide, shininess: 80, wireframe: wf });
        const segMesh = new THREE.Mesh(segGeo, segMat);
        const coneMesh = new THREE.Mesh(coneGeo, coneMat);
        coneMesh.rotation.x = Math.PI;
        coneMesh.position.y = -actualConeHeight / 2; // Apex at origin, base at segment
        group.add(coneMesh);
        group.add(segMesh);
        currentMesh = group;
        currentMesh.castShadow = true;
        scene.add(currentMesh);
        window.updatePosition();
        updateModelInfoBox();
        return;
    }
    if (t === 'zone') {
        // p1=R, p2=H (height of band); show a band in the middle
        const thetaStart = Math.PI / 2 - Math.asin(p2 / (2 * p1));
        const thetaLen = 2 * Math.asin(p2 / (2 * p1));
        g = new THREE.SphereGeometry(p1, 64, 64, 0, Math.PI * 2, thetaStart, thetaLen);
    }
    if (t === 'layer') {
        // Recreate group for layer
        if (currentMesh) {
            scene.remove(currentMesh);
            if (currentMesh.type === 'Group') {
                currentMesh.traverse((child) => {
                    if (child.isMesh) {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    }
                });
            }
        }
        const group = new THREE.Group();
        const avgR = (p1 + p2) / 2;
        const bandHeight = p3;
        const thetaStart = Math.PI / 2 - Math.asin(bandHeight / (2 * avgR));
        const thetaLen = 2 * Math.asin(bandHeight / (2 * avgR));
        const bandGeo = new THREE.SphereGeometry(avgR, 64, 64, 0, Math.PI * 2, thetaStart, thetaLen);
        const col = document.getElementById('meshColor').value;
        const wf = window._wireframeState || false;
        const bandMat = new THREE.MeshPhongMaterial({ color: col, side: THREE.DoubleSide, shininess: 80, wireframe: wf });
        const bandMesh = new THREE.Mesh(bandGeo, bandMat);
        // Calculate actual positions based on sphere geometry
        const yTop = avgR * Math.cos(thetaStart);
        const yBottom = avgR * Math.cos(thetaStart + thetaLen);
        const rTop = avgR * Math.sin(thetaStart);
        const rBottom = avgR * Math.sin(thetaStart + thetaLen);
        const circleGeo1 = new THREE.CircleGeometry(rTop, 64);
        const circleGeo2 = new THREE.CircleGeometry(rBottom, 64);
        const circleMat = new THREE.MeshPhongMaterial({ color: col, side: THREE.DoubleSide, wireframe: wf });
        const circle1 = new THREE.Mesh(circleGeo1, circleMat);
        const circle2 = new THREE.Mesh(circleGeo2, circleMat);
        circle1.rotation.x = -Math.PI / 2;
        circle1.position.y = yTop;
        circle2.rotation.x = -Math.PI / 2;
        circle2.position.y = yBottom;
        group.add(bandMesh);
        group.add(circle1);
        group.add(circle2);
        currentMesh = group;
        currentMesh.castShadow = true;
        scene.add(currentMesh);
        window.updatePosition();
        updateModelInfoBox();
        return;
    }
    if (currentMesh) {
        if (currentMesh.geometry) {
            currentMesh.geometry.dispose();
            currentMesh.geometry = g;
        }
    }
    updateModelInfoBox();
}

window.updateMaterial = function () {
    if (currentMesh) {
        const newColor = document.getElementById('meshColor').value;
        if (currentMesh.type === 'Group') {
            currentMesh.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material.color.set(newColor);
                }
            });
        } else if (currentMesh.material) {
            currentMesh.material.color.set(newColor);
        }
    }
};
window.toggleWireframe = function () {
    if (currentMesh) {
        // Check if it's a group or single mesh
        if (currentMesh.type === 'Group') {
            // Get current state from first mesh
            let newState = true;
            currentMesh.traverse((child) => {
                if (child.isMesh && child.material) {
                    if (newState === true) {
                        newState = !child.material.wireframe;
                    }
                }
            });
            // Apply to all
            currentMesh.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material.wireframe = newState;
                }
            });
            window._wireframeState = newState;
        } else if (currentMesh.material) {
            currentMesh.material.wireframe = !currentMesh.material.wireframe;
            window._wireframeState = currentMesh.material.wireframe;
        }
    }
};
window.updateSlice = function () { clippingPlane.constant = parseFloat(document.getElementById('sliceLevel').value); };
window.updatePosition = function () {
    if (currentMesh) {
        currentMesh.position.x = modelPos.x;
        currentMesh.position.y = modelPos.y;
        currentMesh.position.z = modelPos.z;
    }
};

// Toggle visibility of the model UI panel (useful on small screens)
window.toggleModelUI = function (show) {
    const ui = document.querySelector('.model-ui');
    const openBtn = document.getElementById('openModelUI');
    if (!ui) return;
    if (typeof show === 'undefined') show = (ui.style.display === 'none');
    if (show) {
        ui.style.display = '';
        if (openBtn) openBtn.style.display = 'none';
    } else {
        ui.style.display = 'none';
        if (openBtn) openBtn.style.display = 'flex';
    }
    // ensure renderer updates after layout change
    setTimeout(() => { handleResize(); if (window.adjustPagePadding) adjustPagePadding(); }, 120);
};
function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }

window.onload = function () {
    setLang('hy');
    updateCalcInputs();
    init3D();

    // Ensure canvas sizes correctly after initial layout
    setTimeout(handleResize, 150);

    // Populate and wire language select
    const langSelect = document.getElementById('langSelect');
    if (langSelect) {
        langSelect.addEventListener('change', function () { setLang(this.value); });
    }

    // Populate mobile navigation and wire it
    if (window.populateMobileNav) populateMobileNav();
    const mobile = document.getElementById('mobileNav');
    if (mobile) {
        mobile.addEventListener('change', function () { showPage(this.value); });
    }

    // Ensure page padding accounts for navbar height
    setTimeout(() => { if (window.adjustPagePadding) adjustPagePadding(); }, 220);

    // Initialize model UI open/close state for mobile
    const openBtn = document.getElementById('openModelUI');
    const ui = document.querySelector('.model-ui');
    if (openBtn && ui) {
        if (window.innerWidth <= 900) {
            openBtn.style.display = (ui.style.display === 'none' || getComputedStyle(ui).display === 'none') ? 'flex' : 'none';
        } else {
            openBtn.style.display = 'none';
        }
    }

    // Keep canvas and layout in sync on resize
    window.addEventListener('resize', () => {
        clearTimeout(window._globalResizeTimeout);
        window._globalResizeTimeout = setTimeout(() => { handleResize(); if (window.adjustPagePadding) adjustPagePadding(); }, 150);
    });
    // Add a loaded class to body to trigger CSS entry animations
    setTimeout(() => {
        try { document.body.classList.add('loaded'); } catch (e) { }
    }, 220);

    // Stop the pulsing animation on the calculate button after a while
    setTimeout(() => {
        try { const btn = document.querySelector('.calc-btn'); if (btn) btn.style.animation = 'none'; } catch (e) { }
    }, 6000);
};
